## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/test/common/utils/utils.sh

**Start chunk id:** fc155236a7362577a68772186a8597cdf6ee32a33f3fa5d544fc09b53653e786

## Content

**Question:** What does the `git_get_changed_files` function do and how does it determine the base and head hashes?

**Answer:** The `git_get_changed_files` function determines the base and head hashes to identify the files that have changed between two specific points in a git repository. It first checks for environment variables `O2DPG_TEST_HASH_BASE` and `O2DPG_TEST_HASH_HEAD` to get the base and head hashes. If these variables are not set, it falls back to the environment variables `ALIBUILD_BASE_HASH` and `ALIBUILD_HEAD_HASH`. If these fallback variables are also not set, it defaults to "HEAD~1" for the base hash and "HEAD" for the head hash. This function then uses these hashes to identify the files that have been modified.

The function does not directly retrieve the changed files but uses the hashes to determine the range of changes. To get the actual list of changed files, one would typically use `git diff --name-only ${hash_base} ${hash_head}`, although this specific command is not shown in the provided script.

---

**Question:** What are the default values for `O2DPG_TEST_HASH_BASE` and `O2DPG_TEST_HASH_HEAD` environment variables if they are not set?

**Answer:** The default values for `O2DPG_TEST_HASH_BASE` and `O2DPG_TEST_HASH_HEAD` environment variables, if they are not set, are "HEAD~1" and "HEAD" respectively.

---

**Question:** What are the default values for `O2DPG_TEST_HASH_BASE` and `O2DPG_TEST_HASH_HEAD` environment variables if they are not set, and how are the `hash_base` and `hash_head` variables determined based on these?

**Answer:** The default values for `O2DPG_TEST_HASH_BASE` and `O2DPG_TEST_HASH_HEAD` environment variables, if they are not set, are "HEAD~1" and "HEAD" respectively.

The `hash_base` and `hash_head` variables are determined as follows:
- `hash_base` is assigned the value of `O2DPG_TEST_HASH_BASE` if it is set. If not, it defaults to "HEAD~1".
- `hash_head` is assigned the value of `O2DPG_TEST_HASH_HEAD` if it is set. If not, it defaults to "HEAD".

---

**Question:** What will be the value of `hash_head` if there are unstaged changes and the `ALIBUILD_HEAD_HASH` variable is not set?

**Answer:** The value of `hash_head` will be an empty string ("") if there are unstaged changes and the `ALIBUILD_HEAD_HASH` variable is not set.

---

**Question:** What will be the value of `hash_base` if there are unstaged changes but no `ALIBUILD_HEAD_HASH` or `O2DPG_TEST_HASH_BASE` is set?

**Answer:** hash_base="HEAD"

---

**Question:** What is the purpose of the `paths` variable and how is it determined in the script?

**Answer:** The `paths` variable is used to store a list of file paths that have been modified, added, or renamed in the git repository, excluding deleted files. It is determined by running `git diff --diff-filter=AMR --name-only ${hash_base} ${hash_head}`. This command filters out only the modified, added, and renamed files between the specified base and head, and then the script iterates over these paths, converting each relative path to an absolute path using `realpath`, and concatenating them into the `absolute_paths` string.

---

**Question:** What is the purpose of the `get_workflow_creation_from_script` function?

**Answer:** The purpose of the `get_workflow_creation_from_script` function is to extract the specific line from a script file that creates a workflow, particularly focusing on the line where the `o2dpg_sim_workflow.py` is initiated. It does this by searching through the provided script file line by line, identifying the line that contains this specific file name, and concatenating this line while handling line continuations indicated by backslashes. The function then outputs the assembled workflow creation line without line breaks.

---

**Question:** What is the purpose of the `get_workflow_creation_from_script` function in the provided script?

**Answer:** The `get_workflow_creation_from_script` function is designed to extract the line from a provided script file that creates a workflow. Specifically, it searches for the part of the script where the `o2dpg_sim_workflow.py` file is referenced, and concatenates the relevant lines into a single continuous line, removing any line breaks. This function helps in isolating the workflow creation logic from the rest of the script, making it easier to analyze or modify just the workflow setup part.

---

**Question:** What specific conditions must be met for the `look_for` variable to trigger the assembly of the workflow creation line in the script?

**Answer:** For the `look_for` variable to trigger the assembly of the workflow creation line in the script, the line being read must contain the string "o2dpg_sim_workflow.py". This condition activates the `has_started` flag to 1, initiating the assembly of the workflow creation line.

---

**Question:** What is the purpose of the `has_no_wf` variable in the script?

**Answer:** The purpose of the `has_no_wf` variable is to keep track of whether the script contains the workflow creation command. It is set to 1 initially, indicating that the workflow creation has not yet been found. As the script iterates through each line of the input, if the line contains the workflow creation script (`o2dpg_sim_workflow.py`), `has_no_wf` is set to 0, signaling that the workflow creation has been found. The script then breaks out of the loop. If the workflow creation is found, the script continues to process and outputs the relevant parts of the input script. If the workflow creation is not found (i.e., `has_no_wf` remains 1), the script exits without executing the runner.

---

**Question:** What is the purpose of the variable `has_no_wf` in the script, and how does it affect the output script?

**Answer:** The variable `has_no_wf` is initialized to 1 to indicate that the script has not yet found the `o2dpg_sim_workflow.py` command, which is the marker for the start of the workflow creation section. This variable is used to control the flow of the script, specifically to determine whether to include lines from the input script in the output script. As the script processes each line of the input script, if the current line contains the `o2dpg_sim_workflow.py` command, `has_no_wf` is set to 0, indicating that the workflow creation section has been found. The script then breaks out of the loop, stopping further inclusion of lines from the input script into the output script. However, the script still appends the workflow creation script obtained from `get_workflow_creation_from_script` to the output script, regardless of the value of `has_no_wf`. If the script never finds the `o2dpg_sim_workflow.py` command (i.e., `has_no_wf` remains 1), the output script will not include any lines from the input script, effectively creating an empty output script.

---

**Question:** What specific condition must be met for the script to include the workflow creation line in the output script, and how is this condition checked within the loop?

**Answer:** The specific condition that must be met for the script to include the workflow creation line in the output script is that the line containing "o2dpg_sim_workflow.py" must appear in the input script. This condition is checked within the loop using the following logic:

```bash
[[ "${line}" == *"${look_for}"* ]] && has_no_wf=0
```

When a line containing "o2dpg_sim_workflow.py" is found, `has_no_wf` is set to 0. After this assignment, the script breaks out of the loop using `break` if `has_no_wf` is 0. If `has_no_wf` remains 1, the line is not included in the output script. Once `has_no_wf` is set to 0, subsequent lines are then processed and the workflow creation line is appended to the output script with:

```bash
echo "$(get_workflow_creation_from_script ${full_wf_script})" >> ${out_script}
```

---

**Question:** What does the function `print_error_logs()` do?

**Answer:** The function `print_error_logs()` searches for error logs in a specified directory and prints them out. It starts by defining a local variable `search_dir` for the directory to search in. Then, it sets up a `search_pattern` to look for specific error messages, such as exit codes, segmentation faults, and fatal exceptions. The function uses `find` to locate log files within `search_dir` up to a depth of four, and `grep` to search for the `search_pattern` within these files. It then sorts the found files. For each file containing an error, the function echoes a red message indicating the error and the file's full path. Additionally, it uses `grep` to display the matching lines along with 10 lines of context before and after the match.

---

**Question:** What specific patterns does the `print_error_logs` function look for in log files to identify errors?

**Answer:** The `print_error_logs` function looks for specific patterns such as:

- TASK-EXIT-CODE: followed by a number indicating an exit code
- Segmentation violation
- Segmentation fault
- Program crashed
- Exception caught
- [FATAL]
- Uncaught exception
- A number in parentheses indicating an exit code
- fair::FatalException

These patterns are used to identify potential errors in the log files.

---

**Question:** What specific error patterns does the `print_error_logs` function search for, and how are these patterns defined in the regular expression?

**Answer:** The `print_error_logs` function searches for specific error patterns in log files. These patterns are defined in the regular expression as follows:

1. TASK-EXIT-CODE: ([1-9][0-9]*): Matches exit codes from 1 to 9999.
2. [Ss]egmentation violation: Matches both "Segmentation violation" and "Segmentation violation" (case-insensitive).
3. [Ss]egmentation fault: Matches both "Segmentation fault" and "Segmentation fault" (case-insensitive).
4. Program crashed: Directly matches the phrase "Program crashed".
5. [Ee]xception caught: Matches both "Exception caught" and "Exception caught" (case-insensitive).
6. \[FATAL\]: Matches the phrase "[FATAL]".
7. uncaught exception: Directly matches the phrase "uncaught exception".
8. \(int\) ([1-9][0-9]*): Matches strings in the format "(int) [number]", where [number] is from 1 to 9999.
9. fair::FatalException: Directly matches the phrase "fair::FatalException".

These patterns are combined using the `|` operator in the regular expression to match any of these specific error messages or patterns in the log files.