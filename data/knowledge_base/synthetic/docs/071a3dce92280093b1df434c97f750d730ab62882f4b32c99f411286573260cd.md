## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/UTILS/o2dpg_make_github_pr_report.py

**Start chunk id:** 071a3dce92280093b1df434c97f750d730ab62882f4b32c99f411286573260cd

## Content

DOCUMENT:
    return {'merged': prs_merged,
            'closed': prs_closed,
            'open': prs_open}


def get_prs(owner, repo, request_labels, pr_state=None, per_page=50, start_page=1, pages=1):
    """
    Retrieve pull requests based on certain criteria
    """
    # GitHub API endpoint for listing pull requests with a specific state and label
    prs_return = []

    has_error = False
    for page in range(start_page, pages + 1):
        pr_state_param = f'state={pr_state}&' if pr_state else 'state=all&'
        url = f'https://api.github.com/repos/{owner}/{repo}/pulls?{pr_state_param}page={page}&per_page={per_page}'

        # Send a GET request to the GitHub API
        response = requests.get(url)

---

# if no specific MC or DATA label is specified, consider it valid for both
mc_data = ','.join(mc_data) if mc_data else 'MC,DATA'
merged_at = pr['merged_at'] or 'not merged'
status = pr['state']
for label in labels_take:
    rows_per_label[label].append(f'| {pr["user"]["login"]} | {repo} | [PR]({pr["html_url"]}) | {pr["title"]} | {status} | {merged_at} | {mc_data} |\n')

for label, rows in rows_per_label.items():
    if not rows:
        # no entries to add
        continue
    f.write(f'\n\n### For label {label}\n\n')
    f.write(common_header)
    for row in rows:
        f.write(row)

print(f"==> Report generated and saved to {outfile}")

---

# retrieve all relevant labels
labels = get_labels(args.owner, args.repo, args.label_regex)
# divide into request and acceptance labels, focusing on request labels at present
labels_request, l = separate_labels_request_accept(labels, args.label_accepted_suffix)

# fetch closed pull requests with the given labels, distinguishing between merged and other closed PRs
prs = get_prs(args.owner, args.repo, labels_request, args.pr_state, args.per_page, args.start_page, args.pages)
if not prs:
    print('==> No PRs to report.')
    sys.exit(0)

make_report(prs, args.repo, labels_request, args.label_accepted_suffix, args.output)

sys.exit(0)

---

if __name__ == '__main__':
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description='Fetch closed pull requests with a specific label from a GitHub repository')
    parser.add_argument('--owner', help='GitHub repository owner', default='AliceO2Group')
    parser.add_argument('--repo', required=True, help='GitHub repository name, such as O2DPG or AliceO2')
    parser.add_argument('--pr-state', dest='pr_state', help='The state of the pull request')
    parser.add_argument('--output', help='Name of the output file where the report will be written')
    parser.add_argument('--per-page', dest='per_page', default=100, help='Number of results per page')
    parser.add_argument('--start-page', dest='start_page', type=int, default=1, help='Start on this page')
    parser.add_argument('--pages', type=int, default=5, help='Number of pages')

---

for each_pr in prs:
    if not each_pr['merged_at']:
        if each_pr['state'] == 'open':
            prs_open.append(each_pr)
            open_updated_at.append(each_pr['updated_at'])
            continue
        if each_pr['state'] == 'closed':
            prs_closed.append(each_pr)
            closed_updated_at.append(each_pr['updated_at'])
            continue
    # fetch the PR details and the merged timestamp
    prs_merged.append(each_pr)
    merged_at.append(each_pr['merged_at'])

# arrange the merged PRs based on their merged timestamp
prs_merged = [pr for _, pr in sorted(zip(merged_at, prs_merged))]
prs_closed = [pr for _, pr in sorted(zip(closed_updated_at, prs_closed))]
prs_open = [pr for _, pr in sorted(zip(open_updated_at, prs_open))]

return {'merged': prs_merged,
        'closed': prs_closed,
        'open': prs_open}

---

DOCUMENT:
    labels_request = []
    labels_accept = []

    for label in labels:
        if label.endswith(accept_suffix):
            labels_accept.append(label)
            continue
        labels_request.append(label)

    return labels_request, labels_accept


def make_report(all_prs, repo, labels_request, label_accept_suffix, outfile=None):
    """
    Generate a report

    The report will contain tables for each label, written to a text file.
    """
    # common header for each table
    common_header = '| Requestor | Package | PR | PR title | State | Merged at | Data or MC |\n| --- | --- | --- | --- | --- | --- | --- |\n'

    if not outfile:
        outfile = f'o2dpg_pr_report_{repo}.md'

    with open(outfile, 'w') as f:

        f.write(f'# List PRs for {repo} (from oldest to recent)\n')

        # first list the merged PRs
        for key, prs in all_prs.items():

            rows_per_label = {label: [] for label in labels_request}

---

DOCUMENT:
    rows_per_label = {label: [] for label in labels_request}

            f.write(f'\n\n## PRs in state {key}')
            for pr in prs:
                mc_data = []
                # gather the labels for which the table should include this PR
                labels_take = []

---

DOCUMENT:
    parser.add_argument('--pages', type=int, default=5, help='Specify the number of pages')
    parser.add_argument('--label-regex', dest='label_regex', help='Supply a regular expression to determine which labels to retrieve.', default='^async-\w+')
    parser.add_argument('--label-accepted-suffix', dest='label_accepted_suffix', help='Specify the suffix of labels that indicate acceptance (an automatic dash will be added, so the accepted label should follow the format <request-label>-<accepted-suffix>).', default='accepted')
    parser.add_argument('--include-accepted', action='store_true', help='By default, only PRs are fetched if at least one label does not have the "<label>-accepted" label')
    args = parser.parse_args()

---

#!/usr/bin/env python3

# Retrieve a list of PRs from the specified repository that are labeled with a specific label
# Useful for determining which PRs need to be ported

import sys
import argparse
import requests
import re


def organise_prs(prs):
    """
    Arrange PRs based on their merge time, from oldest to most recent
    """
    # gather merged PRs
    prs_merged = []
    # record the merge times of merged PRs
    merged_at = []
    # track simply closed PRs
    prs_closed = []
    closed_updated_at = []
    # identify open PRs
    prs_open = []
    open_updated_at = []

---

if has_error:
    return None

# separate labels into request and accepted categories
return separate_labels_request_accept(labels, accept_suffix)


def get_labels(owner, repo, regex=None):
    """
    Retrieve labels that match a given regex
    """
    # the REST API URL
    url = f'https://api.github.com/repos/{owner}/{repo}/labels'
    # send a GET request to the GitHub API
    response = requests.get(url)

    if response.status_code != 200:
        print(f'ERROR: Failed to fetch labels for owner {owner} and repository {repo}')
        return None

    return [label['name'] for label in response.json() if not repo or re.match(regex, label['name'])]


def separate_labels_request_accept(labels, accept_suffix=None):
    """
    Separate labels into request and accepted categories
    """
    if not accept_suffix:
        # consider all labels as request labels
        return labels.copy(), []

    labels_request = []
    labels_accept = []

---

DOCUMENT:
    pr_labels = [label['name'] for label in pr['labels']]
    for label_name in pr_labels:
        if label_name not in labels_request:
            continue
        if label_name.lower() in ('mc', 'data'):
            # retrieve the MC or DATA label if this PR possesses it
            mc_data.append(label_name)
        if not label_accept_suffix or f'{label_name}-{label_accept_suffix}' not in pr_labels:
            # verify if the label signifies a request. If the corresponding accepted label also exists, disregard this PR for the report.
            labels_take.append(label_name)

    if not labels_take:
        # no relevant labels
        continue

---

# Issue GET request to GitHub API
    response = requests.get(url)

    # Verify if the request succeeded (status code 200)
    if response.status_code == 200:
        # Parse the JSON response
        prs = response.json()
        # Include PRs that match specific labels
        for pr in prs:
            labels = pr['labels']
            take_pr = False
            for label in labels:
                if label['name'] in request_labels:
                    # Only PRs with the correct label will be accepted
                    take_pr = True
                    break
            if not take_pr:
                continue
            # Proceed if the PR is accepted, then add it
            prs_return.append(pr)

    else:
        print(f'Failed to retrieve data: {response.status_code} - {response.text}')
        has_error = True
        break