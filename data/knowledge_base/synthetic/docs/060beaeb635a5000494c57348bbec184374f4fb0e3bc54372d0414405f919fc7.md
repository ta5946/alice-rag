## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/RelVal/utils/o2dpg_release_validation_plot.py

**Start chunk id:** 060beaeb635a5000494c57348bbec184374f4fb0e3bc54372d0414405f919fc7

## Content

if not values:
    continue

ax.set_xlabel(metric_name, fontsize=20)
ax.set_ylabel("counts", fontsize=20)
ax.hist(values, bins=100)
ax.tick_params("both", labelsize=20)
figure.tight_layout()

figure.suptitle(f"{title} (metric: {metric_name})", fontsize=40)
save_path = join(out_dir, f"histogram_values_{metric_name}.png")
figure.savefig(save_path)
if get_figure:
    return figure
plt.close(figure)


def plot_summary_grid(rel_val, interpretations, interpretation_colors, output_dir, get_figure=False):
    """
    Generate a summary grid per test.

    Horizontal axis: metric names
    Vertical axis: object names

    Each cell is color-coded based on an interpretation.
    Additionally, each cell displays the computed metric values.
    """

---

DOCUMENT:
    ax.pie(counts, explode=[0.05 for _ in counts], labels=labels, autopct="%1.1f%%", startangle=90, textprops={"fontsize": 30}, colors=colors)
        ax.axis("equal")
        ax.axis("equal")

        figure.suptitle(f"{title} (metric: {metric_name}, test: {test_name})", fontsize=40)
        save_path = join(out_dir, f"pie_chart_{metric_name}_{test_name}.png")
        figure.savefig(save_path)
        if get_figure:
            return figure
        plt.close(figure)


def plot_value_histograms(values, out_dir, title="values histogram", get_figure=False):
    """
    Plot a histogram of metric values
    """

    print("==> Plot value histograms <==")
    for metric_name in values.known_metrics:
        figure, ax = plt.subplots(figsize=(20, 20))
        data = []
        for _, _, metric in zip(*values.get_metrics(metric_name=metric_name)):
            if not metric.comparable:
                continue
            data.append(metric.value)

        ax.hist(data, bins=20, edgecolor="black")
        ax.set_title(f"{title} (metric: {metric_name})", fontsize=24)
        ax.set_xlabel("Value")
        ax.set_ylabel("Frequency")
        figure.tight_layout()
        save_path = join(out_dir, f"histogram_{metric_name}.png")
        figure.savefig(save_path)
        if get_figure:
            return figure
        plt.close(figure)

---

DOCUMENT:
    figure.tight_layout()
        figure.savefig(os.path.join(out_dir, f"values_thresholds_{metric_name}_{test_name}.png"))
        if get_figure:
            figures.append(figure)
            continue
        plt.close(figure)
    if get_figure:
        return figures


def plot_overlays(rel_val, file_config_map1, file_config_map2, out_dir, plot_regex=None):
    """
    A wrapper for ROOT overlay plotting
    """
    print("==> Plot overlays <==")
    plot_overlays_root(rel_val, file_config_map1, file_config_map2, out_dir, plot_regex)


def plot_overlays_no_rel_val(file_configs, out_dir):
    """
    A wrapper for ROOT plotting when no RelVal object is provided
    """
    print("==> Plot overlays <==")
    plot_overlays_root_no_rel_val(file_configs, out_dir)

---

#!/usr/bin/env python3
#
# Definition of common functionality

import sys
from os.path import join
from os import environ
import importlib.util
from itertools import product
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import seaborn
from scipy.stats import iqr


O2DPG_ROOT = environ.get("O2DPG_ROOT")
spec = importlib.util.spec_from_file_location("o2dpg_release_validation_utils", join(O2DPG_ROOT, "RelVal", "utils", '.', 'o2dpg_release_validation_utils.py'))
o2dpg_release_validation_utils = importlib.util.module_from_spec(spec)
spec.loader.exec_module(o2dpg_release_validation_utils)
sys.modules["o2dpg_release_validation_utils"] = o2dpg_release_validation_utils
from o2dpg_release_validation_utils import count_interpretations

---

FOR nt IN RANGE(rel_val.number_of_tests):
    metric_names, object_names, results_matrix = rel_val.get_result_matrix_objects_metrics(nt)
    # create an array where each interpretation is converted to a numerical value
    arr_interpretation = np.full(results_matrix.shape, 0, dtype=int)
    # gather annotations for each cell
    arr_annot = np.full(results_matrix.shape, "", dtype=object)
    # iterate through the cells and set values and annotations
    it = np.nditer(results_matrix, flags=['multi_index', "refs_ok"])
    for _ in it:
        result = results_matrix[it.multi_index]
        arr_interpretation[it.multi_index] = interpretation_name_to_number[result.interpretation]
        if result.value is not None:
            annot = f"{result.value:.3f} (mean: {result.mean:.3f})"
            if result.n_sigmas is not None:
                annot += f" (n_sigma: {result.n_sigmas:.3f})"
        else:

---

DOCUMENT:
    interpretation_name_to_number = {v: i for i, v in enumerate(interpretations)}

    colors = [None] * len(interpretation_name_to_number)
    for name, color in interpretation_colors.items():
        colors[interpretation_name_to_number[name]] = color
    cmap = LinearSegmentedColormap.from_list("Custom", colors, len(colors))
    figures = []

---

print("==> Display metric values <==")

figures = []

if not labels:
    labels = [f"summary_{i}" for i, _ in enumerate(rel_vals)]

test_names = list(rel_vals[0].known_test_names)
metric_names = list(rel_vals[0].known_metrics)
for rel_val in rel_vals[1:]:
    test_names = list(set(test_names + list(rel_val.known_test_names)))
    metric_names = list(set(metric_names + list(rel_val.known_metrics)))

---

Each pie chart illustrates the proportion of different interpretations
"""
print("==> Generate pie charts <==")
for metric_name, test_name in product(rel_val.known_metrics, rel_val.known_test_names):
    figure, ax = plt.subplots(figsize=(20, 20))
    # gather counts, colors, and labels for the interpretations
    counts = []
    colors = []
    labels = []
    object_names, results = rel_val.get_result_per_metric_and_test(metric_name, test_name)

    if not len(object_names):
        continue

    for interpretation in interpretations:
        n_objects = len(object_names[count_interpretations(results, interpretation)])
        if not n_objects:
            continue
        counts.append(n_objects)
        colors.append(interpretation_colors[interpretation])
        labels.append(interpretation)

---

ANNOT += f" (n_sigma: {result.n_sigmas:.3f})"
else:
    annot = result.non_comparable_note

---

DOCUMENT:
    arr_annot[it.multi_index] = annot

    # now it's time to plot
    figure, ax = plt.subplots(figsize=(20, 20))
    seaborn.heatmap(arr_interpretation, ax=ax, cmap=cmap, vmin=-0.5, vmax=len(interpretations) - 0.5, yticklabels=object_names, xticklabels=metric_names, linewidths=0.5, annot=arr_annot, fmt="")
    cbar = ax.collections[0].colorbar
    cbar.set_ticks(range(len(colors)))
    cbar.set_ticklabels(interpretations)
    ax.set_title("Test summary [value (mean), (n_sigmas)]", fontsize=30)
    figure.tight_layout()

    if get_figure:
        figures.append(figure)
        continue

    output_path = join(out_dir, f"summary_{rel_val.get_test_name(nt)}.png")
    figure.savefig(output_path)
    plt.close(figure)

    if get_figure:
        return figures


def plot_compare_summaries(rel_vals, out_dir, *, labels=None, get_figure=False):
    """
    Plot the metric values for each object.
    """

---

for each combination of metric_name and test_name in the pairs generated by the product of metric_names and test_names:
    create a figure and axis using plt.subplots with a figure size of 20x20.
    initialize plot_this to False.
    for each rel_val and its corresponding label in the zipped lists of rel_vals and labels:
        retrieve object_names and results using rel_val's get_result_per_metric_and_test method for the current metric_name and test_name.
        extract values and means from the results.
        if no values are present, continue to the next iteration.
        set plot_this to True.
        plot object_names against values and means on the axis with appropriate labels.
    if plot_this remains False, continue to the next iteration.
    add a legend to the plot at the best location with a fontsize of 20.
    adjust the tick parameters for both axes to have a fontsize of 20.
    rotate the x-axis tick labels by 90 degrees.

---

DOCUMENT:
    spec = importlib.util.spec_from_file_location("o2dpg_release_validation_plot_root", join(O2DPG_ROOT, "RelVal", "utils", '.', 'o2dpg_release_validation_plot_root.py'))
o2dpg_release_validation_plot_root = importlib.util.module_from_spec(spec)
spec.loader.exec_module(o2dpg_release_validation_plot_root)
sys.modules["o2dpg_release_validation_plot_root"] = o2dpg_release_validation_plot_root
from o2dpg_release_validation_plot_root import plot_overlays_root, plot_overlays_root_no_rel_val


def plot_pie_charts(rel_val, interpretations, interpretation_colors, out_dir, title="", get_figure=False):
    """
    Generate pie charts for each metric and test
    """