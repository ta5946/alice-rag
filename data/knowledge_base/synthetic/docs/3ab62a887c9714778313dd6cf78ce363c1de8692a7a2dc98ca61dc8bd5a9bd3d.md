## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/MC/bin/o2dpg-workflow-tools.py

**Start chunk id:** 3ab62a887c9714778313dd6cf78ce363c1de8692a7a2dc98ca61dc8bd5a9bd3d

## Content

modify_parser.add_argument("--relative-cpu", dest="relative_cpu", type=float, help="the relative fraction of the maximum available workers")
modify_parser.add_argument("--mem", type=int, help="estimated memory usage")
modify_parser.add_argument("--cmd", help="the command line to be executed")

---

#!/usr/bin/env python3

import sys
from os.path import join, dirname, exists
import argparse

sys.path.append(join(dirname(__file__), '.', 'o2dpg_workflow_utils'))

from o2dpg_workflow_utils import createTask, read_workflow, dump_workflow, check_workflow, update_workflow_resource_requirements, make_workflow_filename

def extend(args):
    """merge another workflow into the original one

    The original workflow's overall configuration remains unchanged
    """
    # load workflows
    workflow_orig, meta = read_workflow(args.orig_wf)
    workflow_extend, _ = read_workflow(args.extend_wf)

    # merge
    workflow_orig.extend(workflow_extend)

    # save to new file
    filename = args.output if args.output else args.orig_wf
    # preserve meta data from the original workflow being extended
    dump_workflow(workflow_orig, filename, meta)

---

def inspect(args):
    """Workflow Inspection

    Currently, this function demonstrates various inspection capabilities.
    """
    workflow, meta = read_workflow(args.file)
    if args.check:
        check_workflow(workflow)
    if args.task:
        task = find_task(workflow, args.task)
        if not task:
            print(f"Task with name {args.task} not found")
            exit(1)
        print("Here are the requested task details")
        print(task)
    if meta:
        print("Here are the metadata details")
        for key, value in meta.items():
            print(f"{key}: {value}")


def main():

    parser = argparse.ArgumentParser(description='Create an ALICE (Run3) MC simulation workflow')

    sub_parsers = parser.add_subparsers(dest="command")

---

DOCUMENT:
    sub_parsers = parser.add_subparsers(dest="command")

    create_parser = sub_parsers.add_parser("create", help="handle workflow management")
    create_parser.set_defaults(func=create)
    create_parser.add_argument("file", help="workflow file to create or modify")
    create_parser.add_argument("--add-task", dest="add_task", nargs="+", help="add named tasks to the workflow file")

    # Append to (sim) workflow
    merge_parser = sub_parsers.add_parser("merge", help="append stages")
    merge_parser.set_defaults(func=extend)
    merge_parser.add_argument("orig_wf", help="original workflow file")
    merge_parser.add_argument("extend_wf", help="workflow JSON to merge into the original")
    merge_parser.add_argument("--output", "-o", help="name of the extended workflow output file", default="workflow_merged.json")

---

DOCUMENT:
    def inspect(args):
    workflow, meta = read_workflow(args.file)
    for task in workflow:
        if task["name"] == args.task:
            print(f"Inspecting task with name {args.task}")
            for attr in ("name", "needs", "timeframe", "cwd", "labels", "cmd"):
                if hasattr(args, attr) and getattr(args, attr) is not None:
                    task[attr] = getattr(args, attr)
            for attr in ("cpu", "relative_cpu", "mem"):
                if hasattr(args, attr) and getattr(args, attr) is not None:
                    task["resources"][attr] = getattr(args, attr)
            break
    else:
        print(f"Task with name {args.task} does not exist")
        exit(1)
    dump_workflow(workflow, args.file, meta=meta)

---

modify_parser = sub_parsers.add_parser("modify", help="adjust a task within the workflow")
modify_parser.set_defaults(func=modify)
modify_parser.add_argument("file", help="the workflow file to be adjusted")
modify_parser.add_argument("task", help="name of the task to be modified")
# currently, renaming the task is not supported as it affects the log-file name
#modify_parser.add_argument("--name", help="new name for this task")
modify_parser.add_argument("--needs", nargs="+", help="tasks that must be completed before this one")
modify_parser.add_argument("--timeframe", type=int, help="timeframe for the task")
modify_parser.add_argument("--cwd", help="current working directory for this task")
modify_parser.add_argument("--labels", nargs="+", help="labels attached to this task")
modify_parser.add_argument("--cpu", type=int, help="number of workers to be used for this task")

---

DOCUMENT:
    def create(args):
    """create an empty workflow structure or append task skeletons to an existing workflow
    """
    filename = make_workflow_filename(args.file)
    if not args.add_task and os.path.exists(filename):
        print(f"Workflow file {filename} already exists. Please delete it and try again.")
        return
    if not args.add_task or not os.path.exists(filename):
        # simply create an empty workflow
        dump_workflow([], filename)
    if args.add_task:
        # append task skeletons with specified names
        workflow, meta = read_workflow(filename)
        for name in args.add_task:
            workflow.append(createTask(name=name))
        dump_workflow(workflow, filename, meta=meta)


def find_task(workflow, task_name):
    for s in workflow:
        if s["name"] == task_name:
            return s
    return None

---

DOCUMENT:
    inspect_parser = sub_parsers.add_parser("inspect", help="examine a workflow")
    inspect_parser.set_defaults(func=inspect)
    inspect_parser.add_argument("file", help="Workflow file to examine")
    inspect_parser.add_argument("--check", action="store_true", help="Verify the workflow's integrity")
    inspect_parser.add_argument("--task", help="name of task to examine in detail")

    args = parser.parse_args()

    if not hasattr(args, "func"):
        parser.parse_args(["--help"])
        exit(0)

    args.func(args)


if __name__ == "__main__":
    # offer this as a standalone option if run directly from the interpreter
    main()

---

nworker_parser = sub_parsers.add_parser("nworkers", help="adjust the number of workers")
nworker_parser.set_defaults(func=nworkers)
nworker_parser.add_argument("file", help="the workflow file that needs to be edited")
nworker_parser.add_argument("jobs", type=int, help="the new number of workers to recalculate based on CPU")