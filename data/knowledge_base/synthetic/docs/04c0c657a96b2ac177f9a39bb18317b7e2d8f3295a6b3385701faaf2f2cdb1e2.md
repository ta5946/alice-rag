## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/test/run_generator_tests.sh

**Start chunk id:** 04c0c657a96b2ac177f9a39bb18317b7e2d8f3295a6b3385701faaf2f2cdb1e2

## Content

get_git_repo_directory()
{
    local repo=
    if [[ -d .git ]] ; then
        pwd
    else
        repo=$(git rev-parse --git-dir 2> /dev/null)
    fi
    [[ "${repo}" != "" ]] && repo=${repo%%/.git}
    echo ${repo}
}

---

DOCUMENT:
REPO_DIR=${O2DPG_TEST_REPO_DIR:-$(get_git_repo_directory)}
if [[ ! -d ${REPO_DIR}/.git ]] ; then
    echo "ERROR: The directory \"${REPO_DIR}\" is not a git repository."
    exit 1
fi

if [[ -z ${O2DPG_ROOT+x} ]] ; then
    echo "ERROR: O2DPG is not loaded, indicating that other required packages might be missing."
    exit 1
fi

# source the utilities
source ${REPO_DIR}/test/common/utils/utils.sh

# Perform initial steps in the source directory where a complete git repository is available
pushd ${REPO_DIR} > /dev/null

# Add the ini files that have been modified to ensure we have the necessary information for missing tests and other details.
collect_ini_files

if [[ -z "${INI_FILES}" ]] ; then
    echo
    echo "No items to test were found."
    echo
    exit 0
fi

if [[ -n "${TEST_WITHOUT_INI}" ]] ; then
    echo_red "Warning: Some test macros do not match any INI file:"
    for twi in ${TEST_WITHOUT_INI} ; do
        echo "  - ${twi}"
    done
    exit 1
fi

---

####################
# Gather cmd args #
####################

# determine if the script should terminate upon the first test failure
fail_immediately=
[[ "${1}" == "--fail_immediately" ]] && fail_immediately=1

while [ "$1" != "" ] ; do
    case $1 in
        --fail_immediately ) shift
                             fail_immediately=1
                             ;;
        --keep-artifacts )   shift
                             KEEP_ONLY_LOGS=0
                             ;;
        --help|-h )          print_usage
                             exit 1
                             ;;
        * )                  echo "Unrecognized argument ${1}"
                             exit 1
                             ;;
    esac
done

echo
echo "################################"
echo "# Execute O2DPG simulation test #"
echo "################################"
echo

---

exec_test()
{
    # perform a single test for a specified ini file and generator
    # we assume we are currently in the intended test directory
    local ini_path=${1}
    local generator=${2} # currently either "Pythia8" or "External", and the generator's settings are assumed to be in this ini file
    local generator_lower=$(echo "${generator}" | tr '[:upper:]' '[:lower:]')
    # TODO Possibly, an external generator derived from GeneratorPythia8 could be run, which might utilize settings from TriggerPythia8
    local trigger=${3:+-t ${generator_lower}}
    local RET=0
    # the expected invocation format for our test script
    local test_script=$(get_test_script_path_for_ini ${ini_path})
    # initialize the log file headers
    echo "### Testing ${ini_path} with generator ${generator} ###" > ${LOG_FILE_KINE}
    echo "### Testing ${ini_path} with generator ${generator} ###" > ${LOG_FILE_GENERIC_KINE}

---

# Set up some colored output
SRED="\033[0;31m"
SGREEN="\033[0;32m"
SEND="\033[0m"


echo_green()
{
    echo -e "${SGREEN}${*}${SEND}"
}


echo_red()
{
    echo -e "${SRED}${*}${SEND}"
}


# Avoid sourcing the script to prevent any unforeseen issues when exit is used
SCRIPT_NAME="$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")"
if [ "${SCRIPT_NAME}" != "$(basename ${BASH_SOURCE[0]})" ] ; then
    echo_red "This script cannot be sourced" >&2
    return 1
fi


##################################
# Core and utility functionality #
##################################

---

print_usage()
{
    echo
    echo "usage: run_generator_tests.sh [--fail-immediately] [--keep-artifacts]"
    echo
    echo "  FLAGS:"
    echo
    echo "  --fail-immediately : halt immediately upon the first test failure"
    echo "  --keep-artifacts : retain simulation and tests artifacts; by default, only logs are preserved post each test"
    echo
    echo "  ENVIRONMENT VARIABLES:"
    echo
    echo "  O2DPG_TEST_REPO_DIR : Specify the source repository to test."
    echo "  O2DPG_TEST_HASH_BASE : The base hash for comparison (optional)"
    echo "  O2DPG_TEST_HASH_HEAD : The head hash for comparison (optional)"
    echo
    echo "  If O2DPG_TEST_HASH_BASE is not defined, ALIBUILD_BASE_HASH will be checked."
    echo "  If ALIBUILD_BASE_HASH is also undefined, it defaults to HEAD~1. However, if there are uncommitted changes, it defaults to HEAD."
    echo
}

---

The document states:
Following INI files will be tested:
ini_files_full_paths=
for ini in ${INI_FILES} ; do
    echo "  - ${ini}"
    # convert to full path so that we can find it from anywhere
    ini_files_full_paths+="$(realpath ${ini}) "
done

# return to the previous directory
popd > /dev/null

# now, we perform the trick:
# we utilize the source directory since O2DPG's installation is essentially a copy of the entire repository.
# this is especially useful for local testing and also works in the CI environment. Instead of
#         [[ -z {ALIBUILD_HEAD_HASH+x} ]] && export O2DPG_ROOT=${REPO_DIR}
# we will maintain consistency and set
export O2DPG_ROOT=${REPO_DIR}
export O2DPG_MC_CONFIG_ROOT=${O2DPG_ROOT}

# prepare our local test directory
rm -rf ${TEST_PARENT_DIR} 2>/dev/null
mkdir -p ${TEST_PARENT_DIR} 2>/dev/null
pushd ${TEST_PARENT_DIR} > /dev/null

# define a global return code to be returned at the end
ret_global=0

---

# proceed with the standard test on the kinematics
root -l -b -q ${O2DPG_ROOT}/test/common/kine_tests/test_generic_kine.C >> ${LOG_FILE_GENERIC_KINE} 2>&1
RET=${?}

# execute the known test script
cp ${test_script} ${generator}.C
root -l -b -q ${generator}.C >> ${LOG_FILE_KINE} 2>&1
local ret_test=${?}
if [[ "${RET}" != "0" ]]; then RET=${ret_test}; fi
rm ${generator}.C

remove_artifacts
return ${RET}
}

---

# this depends on INI_FILES and MACRO_FILES_POTENTIALLY_INCLUDED
# gather all INI files that might contain modified macros
local macros=
for m in ${changed_files} ; do
    [[ "${m}" != *"MC/config"*".C" ]] && continue
    macros+=" ${m} "
done

add_ini_files_from_macros ${macros}

# this relies on MACRO_FILES_POTENTIALLY_INCLUDED
# gather all INI files that might have macros which in turn include modified macros
# for now, only consider one level of inclusion, in principle, we could do this recursively
add_ini_files_from_macros $(find_including_macros)

# also, if tests have changed, we should run them
local macros=
for m in ${changed_files} ; do
    [[ "${m}" != *"MC/"*"ini/tests"*".C" ]] && continue
    macros+=" ${m} "
done
add_ini_files_from_tests ${macros}
}

---

DOCUMENT:
    local including_file=${including%:*}
    local included_file=${including##*:}
    # extract only the blank file path that is included
    included_file=${included_file##* }
    included_file=${included_file##\"}
    included_file=${included_file%%\"}
    # verify if the included file is relative to this directory
    local included_file_this_dir=$(dirname ${including_file})/${included_file}
    included_file_this_dir=$(realpath $included_file_this_dir)
    included_file_this_dir=${included_file_this_dir##${repo_dir_head}/}
    if [[ -f ${included_file_this_dir} && "${changed_files}" == *"${included_file_this_dir}"* ]]; then
        [[ "${including_macros}" == *"${including_file}"* ]] && continue
        including_macros+="${including_file} "
        continue
    fi

---

DOCUMENT:
    echo "  If not specified, it will default to HEAD."
    echo
    echo "  If O2DPG_TEST_HASH_HEAD is unset, ALIBUILD_HEAD_HASH will be checked."
    echo "  If that is also unset, it will default to HEAD, but will remain empty if there are unstaged changes."
    echo
}

---

check_generators()
{
    # verify all generators listed in the INI file
    local ini_path=${1}
    local generators_to_check=""
    # overall return status for this verification
    local ret_this=0
    # ensure there is a test script
    local test_script=$(get_test_script_path_for_ini ${ini_path})
    local tested_any=
    [[ ! -f ${test_script} ]] && { echo_red "[FATAL]: O2DPG_TEST Script ${test_script} not specified for ini file ${ini_path}" | tee -a ${LOG_FILE_KINE} ; return 1 ; }
    for g in ${CHECK_GENERATORS} ; do
        # proceed only if the generator is referenced in the INI file
        if [[ "$(grep ${g} ${ini_path})" != "" ]] ; then
            local look_for=$(grep " ${g}.*\(\)" ${test_script})
            local has_trigger="$(grep Trigger${g} ${ini_path})"
            [[ -z "${look_for}" ]] && continue
            echo -n "Test ${TEST_COUNTER}: ${ini_path} with generator ${g}"
            tested_any=1
            # set up the test directory

}

---

get_test_script_path_for_ini()
{
    local ini_path=${1}
    local test_script=$(basename ${ini_path})
    local path_to_test_script=$(dirname ${ini_path})/tests/${test_script%.ini}.C
    if [[ ! -f ${path_to_test_script} ]] ; then
        # Verify if test redirection is applied within the ini_path file using the #---> syntax
        local redirection=$(grep "#--->" ${ini_path})
        if [[ "${redirection}" != "" ]] ; then
            test_script=$(echo ${redirection} | awk '{print $2}')
            path_to_test_script=$(dirname ${ini_path})/tests/${test_script}.C
        fi
    fi
    echo ${path_to_test_script}
}

---

add_ini_files_from_macros()
{
    # given a list of macros, gather all INI files that include at least one of them
    local macro_files=$@
    for mf in ${macro_files} ; do
        # Remove any part of the path before MC/config/, to get the macro's relative path
        if [[ "${mf}" == *"MC/config"* ]] ; then
            mf=${mf#*MC/config/}
            mf="MC/config/${mf}"
        fi
        local other_ini_files=$(grep -r -l ${mf} | grep ".ini$")
        # if this macro is not found in any INI file, it might be included by another macro which is then included in an INI file
        [[ -z "${other_ini_files}" ]] && { MACRO_FILES_POTENTIALLY_INCLUDED+="${mf} " ; continue ; }
        for oif in ${other_ini_files} ; do
            # add to the INI files collection if not already included
            [[ "${INI_FILES}" ==  *"${oif}"* ]] && continue
            INI_FILES+=" ${oif} "
        done
    done
}

---

#!/bin/bash

######################################
# Entry point for O2DPG tests related #
######################################

CHECK_GENERATORS="Pythia8 External"

# The parent directory for test files within the current directory
TEST_PARENT_DIR="o2dpg_tests/generators"

# Unified names for log files from simulation and test macros
LOG_FILE_SIM="o2dpg-test-sim.log"
LOG_FILE_KINE="o2dpg-test-kine.log"
LOG_FILE_GENERIC_KINE="o2dpg-test-generic-kine.log"

# Gather any macro files that are indirectly used in INI files, but could be included in other macros
MACRO_FILES_POTENTIALLY_INCLUDED=""

# Global variable to gather all INI files to be tested
INI_FILES=""

# Collect test macros that lack corresponding INI files
TEST_WITHOUT_INI=""

# A global counter for tests
TEST_COUNTER=1

# Option to keep only logs or delete everything else (default is to delete)
KEEP_ONLY_LOGS=1

# Prepare colored output
SRED="\033[0;31m"
SGREEN="\033[0;32m"
SEND="\033[0m"

---

DOCUMENT:
    including_macros+="${including_file} "
                continue
            fi
            # verify if R__ADD_INCLUDE_PATH is utilized in the including macro and validate the included files against that
            for root_included in $(get_root_includes ${including_file} ${included_file}) ; do
                if [[ "${changed_files}" == *"${root_included}"* ]] ; then
                    [[ "${including_macros}" == *"${including_file}"* ]] && continue
                    including_macros+="${including_file} "
                    continue
                fi
            done
        done <<< "$(grep -r include.*${base})"
    done
    echo ${including_macros}
}

    PARAPHRASED DOCUMENT:

---

get_root_includes()
{
    # verify if R__ADD_INCLUDE_PATH is utilized within the including macro and then check the included file against this path
    local including_file=${1}
    local included_file=${2}
    full_includes=""
    while read -r line ; do
        # remove all unnecessary parts, as R__ADD_INCLUDE_PATH typically points to something like $O2DPG/<what/we/are/interested/in> and we need only the file name
        included_file_this_dir=${line#*/}
        # remove the closing parenthesis to clean up the path
        included_file_this_dir=${included_file_this_dir%%")"}
        # build the full file path
        included_file_this_dir=${included_file_this_dir}/${included_file}
        # ensure the file exists and hasn't already been added to the list
        [[ -f ${included_file_this_dir} && "${full_includes}" != *"${included_file_this_dir}"* ]] && full_includes+="${included_file_this_dir} "
    done <<< "$(grep R__ADD_INCLUDE_PATH ${including_file})"
    echo ${full_includes}
}

---

DOCUMENT:
    add_ini_files_from_tests()
    {
        # Gather INI files that have been modified in the tests
        local test_changed=$@
        for tc in ${test_changed} ; do
            local ini_dir=$(dirname ${tc})
            ini_dir=${ini_dir%%/tests}
            local keep_test_name=${tc}
            tc=$(basename ${tc})
            tc=${tc%.C}.ini
            tc=${ini_dir}/${tc}
            [[ "${INI_FILES}" == *"${tc}"* ]] && continue
            # this INI file does not exist, it is a test without an INI file --> to be improved for detection
            [[ ! -f ${tc} ]] && { TEST_WITHOUT_INI+="${keep_test_name} " ; continue ; }
            INI_FILES+=" ${tc} "
        done
    }


    collect_ini_files()
    {
        # Gather all INI files that have been modified
        local changed_files=$(git_get_changed_files)
        for ini in ${changed_files} ; do
            [[ "${ini}" != *"MC/config"*".ini" ]] && continue
            [[ "${INI_FILES}" == *"${ini}"* ]] && continue || INI_FILES+=" ${ini} "
        done
    }

---

DOCUMENT:
    echo "### Testing ${ini_path} with generator ${generator} ###" > ${LOG_FILE_GENERIC_KINE}
    echo "### Testing ${ini_path} with generator ${generator} ###" > ${LOG_FILE_SIM}
    # execute the simulation, stop if it fails
    o2-sim -g ${generator_lower} ${trigger} --noGeant -n 100 -j 4 --configFile ${ini_path} --configKeyValues "GeneratorPythia8.includePartonEvent=true" >> ${LOG_FILE_SIM} 2>&1
    RET=${?}
    [[ "${RET}" != "0" ]] && { remove_artifacts ; return ${RET} ; }

---

# global return code to be returned at the end
ret_global=0

# examine each INI file
for ini in ${ini_files_full_paths} ; do

    # apply some matching if requested
    check_this="1"
    echo "Examining ${ini}"
    if [[ "${O2DPG_CHECK_FILTER}" ]]; then
      echo "Using filter ${O2DPG_CHECK_FILTER} for the check"
      if [[ "${ini}" == *"${O2DPG_CHECK_FILTER}"* ]]; then
        check_this="1"
      else
        check_this="0"
      fi
    fi

    if [[ "${check_this}" == "0" ]]; then
      continue
    fi

    check_generators ${ini}
    RET=${?}
    if [[ "${RET}" != "0" ]] ; then
        ret_global=${RET}
        [[ "${fail_immediately}" == "1" ]] && break
    fi
done
# return to the previous directory
popd > /dev/null

# display log files of failed tests
if [[ "${ret_global}" != "0" ]] ; then
    print_error_logs ${TEST_PARENT_DIR}
    exit ${ret_global}
fi

echo
echo_green "All generator tests passed successfully"
echo

exit 0

---

find_including_macros()
{
    # determine the macros that include other macros that have been modified, thereby enabling us to check
    # if these including macros are present in certain INI files
    local repo_dir_head=${REPO_DIR}
    local changed_files=$(git_get_changed_files)
    local potentially_included=${MACRO_FILES_POTENTIALLY_INCLUDED}
    # we reset it here but could refill it to perform a full recursive check
    MACRO_FILES_POTENTIALLY_INCLUDED=""
    # collection of including macros based on w
    local including_macros=""
    for pi in ${potentially_included} ; do
        local base=$(basename ${pi})
        # examine all files that include this one
        while read -r including ; do
            # terminate the loop if no match is found
            [[ -z "${including}" ]] && break
            # some renaming steps
            local including_file=${including%:*}
            local included_file=${including##*:}
}

---

DOCUMENT:
    tested_any=1
            # set up the test directory
            local test_dir=${TEST_COUNTER}_$(basename ${ini})_${g}_dir
            rm -rf ${test_dir} 2> /dev/null
            mkdir ${test_dir}
            pushd ${test_dir} > /dev/null
                # run a single test
                exec_test ${ini_path} ${g} ${has_trigger}
                RET=${?}
            popd > /dev/null
            if [[ "${RET}" != "0" ]] ; then
                echo_red " -> FAILED"
                ret_this=${RET}
            else
                echo_green " -> PASSED"
            fi
            ((TEST_COUNTER++))
        fi
    done
    [[ -z "${tested_any}" ]] && { echo_red "No test scenario was identified for any generator. At least one generator must be present for testing." ; ret_this=1 ; }
    return ${ret_this}
}