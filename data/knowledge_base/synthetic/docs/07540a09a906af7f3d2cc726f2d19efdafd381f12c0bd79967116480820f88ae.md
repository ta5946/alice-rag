## Metadata

**Document link:** https://github.com/AliceO2Group/AliceO2/blob/dev/doc/DetectorSimulation.md

**Start chunk id:** 07540a09a906af7f3d2cc726f2d19efdafd381f12c0bd79967116480820f88ae

## Content

## Adjustable Parameters

The simulation utilizes `adjustable parameters` as detailed in the [ConfigurableParam.md](https://github.com/AliceO2Group/AliceO2/blob/dev/Common/SimConfig/doc/ConfigurableParam.md) documentation. Both the detector code and the general simulation code declare and utilize these parameters during runtime. Once a parameter is defined, it can be modified or set externally through configuration files or command-line inputs, such as `--configFile` and `--configKeyValues`. The full list of parameters along with their default values can be found in `o2sim_configuration.ini`, which is generated by running `o2-sim -n 0 -m CAVE` with no events.

Key parameters that affect the transport simulation include:

---

Similarly, during the reconstruction workflow, the `HBFUtils` settings utilized by `o2-sim-digitizer-workflow` will be loaded (though they can be overridden by using the `--hbfutils-config <ini-file>` option or by specifying `--configKeyValues "HBFUtils...` directly). The DPL ensures that the `DataHeader.firstTForbit` matches the 1st orbit of the TF containing `HBFUtils.orbitFirstSampled`, and for subsequent TFs, it increments by `HBFUtils.nHBFPerTF` if the digitized files contain multiple TF entries.

## Embedding <a name="Embedding"></a>

## Monte Carlo Labels <a name="MCLabels"></a>

We can link digits to the original tracks/particles from the transport simulation to maintain information about their origin. This provenance can be preserved through reconstruction and analysis, aiding in studies of reconstruction efficiencies and more.

---

* **Advanced Control** via environment variables:
`o2-sim` can be customized using these environment variables:

| Variable | Description |
| --- | --- |
| **ALICE_O2SIM_DUMPLOG** | If set, the logs from all FairMQ components will be displayed on the screen and can be redirected to a user-defined log file. |
| **ALICE_NOSIMSHM** | When set, communication between simulation processes will use ROOT serialization instead of a shared memory mechanism. |


## Adjustable Parameters

---

// Loop through every event in the file
for (int event = 0; event < reader.getNEvents(0); ++event) {
  // Retrieve all Monte Carlo tracks for this specific event
  const std::vector<MCTrack>& tracks = reader.getTracks(event);

  // Process the tracks
}
```


# Simulation Tutorials/Examples <a name="Examples"></a>

A collection of examples demonstrating the use of simulation and digitization can be found in the [examples folder](../run/SimExamples). Additional resources include the scripts utilized for regression testing in [prodtests](../prodtests).

---

Digitization - the process of converting hits generated in the transport simulation into the format of the electronics detector output - is managed by the `o2-sim-digitizer-workflow` executable. This executable is structured as a [DPL workflow] (https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/Core/README.md). Key components of this workflow include:
- A **SimReader** process, tasked with analyzing simulation data/kinematics and establishing the digitization context. This context details aspects like the timeframe structure (bunch crossing properties and interaction rate) and the method for merging background and signal hits.
- Specific **Digitizer processors** for each detector, which handle the actual digitization, receiving the digitization context from the SimReader.
- **IO processors** for each detector, responsible for writing the digitized data to files.
- A **GRP updater** process, which updates the GRP file with information gathered during the digitization process.

---

Custom triggers can also be built by the user to meet specific needs with unlimited flexibility.
An external trigger function can be set using command-line arguments:
```
o2-sim -g pythia8pp -t external --configKeyValues 'TriggerExternal.fileName=path_to_trigger_macro.C;TriggerExternal.funcName="the_function(some, parameters)"'
```
This function must adhere to a simple protocol and return a lambda function structured like this:
```
o2::eventgen::Trigger the_function()
{
  return [](const std::vector<TParticle>& particles) -> bool {
    return true; // triggered
  }
}
```
In the lambda function, users have access to the generated particles and can examine them to create a trigger as desired.
The trigger is activated when the lambda function returns `true`, and the current event's simulation is then initiated.

---

The key element is `HBFUtils.orbitFirstSampled`, which instructs `InteractionSampler` about the starting orbit for sampling. Other parameters, `nHBFPerTF` and `orbitFirst`, do not直接影响数字化过程，但它们被存储在`grp`对象中(`o2sim_grp.root`文件)并记录了每个TF的轨道数量及运行的第一个轨道。
`HBFUtils`的完整内容存储在`o2simdigitizerworkflow_configuration.ini`中，并在重建和MC到原始数据转换过程中使用。
特别地，在生成原始数据时(参见`O2/prodtests/full_system_test.sh`中的`...-digi2raw`组命令)，`HBFUtils`的设置将从这个ini文件中加载(可以通过`--hbfutils-config <ini-file>`选项更改文件名)，`HBFUtils.orbitFirst`用于确定运行的起始标志(`RDH中的SOX标志`)，`HBFUtils.nHBFPerTF`用于将数字化数据分割成TF。

---

| Example               | Short Description                                                                      |
| --------------------- | -------------------------------------------------------------------------------------- |
| [HF_Embedding_Pythia8](../run/SimExamples/HF_Embedding_Pythia8) | Demonstrates setting up a detailed HF simulation for embedding purposes.          |
| [AliRoot_Hijing](../run/SimExamples/AliRoot_Hijing) | Illustrates using Hijing within AliRoot for generating events.                       |
| [AliRoot_AMPT](../run/SimExamples/AliRoot_AMPT) | Provides guidance on utilizing AMPT within AliRoot for event generation.            |
| [Adaptive_Pythia8](../run/SimExamples/Adaptive_Pythia8) | Complex example showcasing **generator configuration for embedding** that adapts to the background event. |
| [Signal_ImpactB](../run/SimExamples/Signal_ImpactB) | Example highlighting **generator configuration for embedding** that adjusts based on the impact parameter of the background event. |

---

## Usage overview:
* **Quick start example:** A basic invocation looks like

    ```o2-sim-digitizer-workflow [--sims foo] -b``` 

    which starts the digitization process for all detectors involved in a simulation with the default prefix `foo` (set to o2sim by default) and processes all events using the standard bunch crossing configuration. All digitizers operate in parallel.

* **More advanced example:** 

    ```o2-sim-digitizer-workflow --sims bkg,sgn --interactionRate 1e6 --onlyDet TPC,ITS -b``` 

    which initiates the digitization for the TPC and ITS detectors with a specified LHC interaction rate. This example also combines digitization results from both background (using prefix bkg) and signal (using prefix sgn) simulations.

---

To enable users to create triggers that extend beyond the standard particle stack produced by the event generator, an additional feature is introduced. This feature permits users to delve into the core processes of the event generator, whenever feasible. Due to this, it is referred to as a 'DeepTrigger'. A 'DeepTrigger' is integrated into the simulation in the same manner as a regular trigger:

```
o2-sim -g pythia8pp -t external --configKeyValues 'TriggerExternal.fileName=path_to_deep_trigger_macro.C;TriggerExternal.funcName="the_deep_function(some, parameters)"'
```

Here, the function must adhere to a modified protocol and should return a lambda function defined as follows:

``` o2::eventgen::DeepTrigger the_deep_function()
{
  return [mpiMin](void* interface, std::string name) -> bool {
    return true;
  };
}
```

It's important to note that in this scenario, the user receives a pointer to the event-generator interface along with a string that specifies the name of the event.

---

### Advanced Triggers
Advanced triggers is a term for a new feature that enables users to define custom functions with direct access to the event generator interface. This feature adheres to the structure outlined previously, allowing users to supply a custom lambda function that will be passed a pointer to the internal event-generator interface object (e.g., for Pythia8, a pointer to the Pythia object) and a tagname for identification. This capability could be beneficial for users needing to implement triggers based on data beyond the generated particle stack, leveraging additional internal counters or information within the event generator.

Here is an example of an advanced trigger implementation in Pythia8.

```
//   usage: o2sim --trigger external --configKeyValues 'TriggerExternal.fileName=trigger_mpi.C;TriggerExternal.funcName="trigger_mpi()"'

#include "Generators/Trigger.h"
#include "Pythia8/Pythia.h"
```

---

#### 6. **How do I configure a trigger in the event generator?**
Event generators adhering to the `o2::eventgen::Generator` protocol can be set to trigger under specific conditions.
A fundamental 'particle trigger' feature is available in the `o2::eventgen` core, enabling users to specify a trigger particle.
The criteria for the trigger particle can be set using command line options:
```
o2-sim -g pythia8pp -t particle --configKeyValues "TriggerParticle.pdg=333;TriggerParticle.ptMin=5.;TriggerParticle.yMin=-0.5;TriggerParticle.yMax=0.5"
```

---

| Option                | Description                                                                            |
| --------------------- | -------------------------------------------------------------------------------------- |
| -h,--help     | Displays the list of available command line options and their default values.           |
| --sims | A comma-separated list of simulation prefixes for overlay/embedding. For example, `--sims background,signal` where `background` and `signal` represent different transport simulation productions. Final collisions are formed from both (using a round robin approach). For more information, see the [Embedding](#Embedding) section. If only one prefix is specified, standard digitization without overlay is performed. |
| --tpc-lanes | The number of parallel TPC digitizers, considering the increased data rate compared to other detectors. |
| --interactionRate | The total hadronic interaction rate (Hz). |

---

For this purpose, a specialized data object `MCCompLabel` is provided, enabling the encapsulation of identifiers for track, event, and source kinematics files. 
```c++
  MCCompLabel(int trackID, int evID, int srcID, bool fake = false)
```
This data should suffice for locating and loading the specific Monte Carlo track ([refer here](#MCReader)).

Linking digits to an arbitrary set of labels is achieved by populating a **separate** and **dedicated** container called `MCTruthContainer`, which is written as a distinct branch in the output file alongside the branch for digits. This approach ensures that digits remain closely aligned with raw data while allowing for an unlimited number of labels with minimal memory overhead.

---

This procedure, referred to as embedding, involves combining two events generated independently. To ensure physical accuracy, these events must share the same interaction vertex.

If you have background events already stored in the `o2sim.background.root` file, you can generate a new set of events with the same interaction vertex as the background events using this command line option:

```
o2-sim --embedIntoFile o2sim.background.root
```

Background events are sequentially selected until all are used, after which they begin to be repeated.

---

| --interactionRate | Total rate of hadronic interactions (Hz). |
| --bcPatternFile | File defining a different bunch crossing pattern than the default, see `macro/CreateBCPattern.C` for more details. |
| --onlyDet | List of detectors to be digitized, separated by commas (default is all). |
| --skipDet | List of detectors to exclude from digitization, separated by commas. |
| --incontext | Name of the context file to be used, useful for reusing a context from a prior run when processing detectors separately. |
| --outcontext | Specify the name of the context file to be created. |
| --simFileQED | Optional QED hit file that can be included to incorporate the effects of QED into the digitization process. |

---

## Guidance on Available Generators

Here are some notes on example generators, along with usage instructions.

* **Fwmugen**

fwmugen is a straightforward generator for creating forward muons (one muon per event).

```
o2-sim -m MFT -e TGeant3 -g fwmugen -n 10
```

* **BoxGen**

```
o2-sim -m PIPE ITS MFT -e TGeant3 -g boxgen -n 10 --configKeyValues 'BoxGun.pdg=13 ; BoxGun.eta[0]=-3.6 ; BoxGun.eta[1]=-2.45; BoxGun.number=100'
```
This command generates 10 events with 100 forward muons.

* **PYTHIA 8**

Sets up pythia8 for minimum bias pp collisions at 14 TeV.

```
o2-sim -m PIPE ITS MFT -g pythia8pp -n 50
```

[Provide a detailed explanation of the environment variables]

## Data Layout
[Include information about the structure of the hits file]

## Frequently Asked Questions
Feel free to contribute to the documentation by posing a question.

---

| Option                | Description                                                                            |
| --------------------- | -------------------------------------------------------------------------------------- |
| -h,--help     | Displays the list of available command line options along with their default values.   |
| -n,--number | Specifies the number of events to be simulated.                                         |
| -g,--generator | Utilizes a predefined generator template by name (e.g., pythia8pp, pythia8hi). The configuration details for generations are explained in a separate section. |
| -e,--engine | Chooses the VMC transport engine (TGeant4, TGeant3).                                   |
| -m,--modules | Includes a list of modules/geometries to be used (default is ALL); for example, -m PIPE ITS TPC |
| -j,--nworkers | Sets the number of parallel simulation engine workers (default is half the number of hyperthread CPU cores) |

---

#include "Generators/Trigger.h"
#include "Pythia8/Pythia.h"

o2::eventgen::DeepTrigger
  trigger_mpi(int mpiMin = 5)
{
  return [mpiMin](void* interface, std::string name) -> bool {
    if (name == "pythia8") {
      auto py8 = reinterpret_cast<Pythia8::Pythia*>(interface);
      return py8->info.nMPI() >= mpiMin;
    }
    LOG(fatal) << "Cannot define MPI for generator interface \'" << name << "\'";
    return false;
  };
}
```


### Pythia8 UserHooks
Pythia8 provides functionality for users to insert custom code at specific points during the event-generation process. For more information, refer to the Pythia8 manual:
http://home.thep.lu.se/~torbjorn/pythia82html/UserHooks.html

The interface for this is configured through a macro where the user must define a custom UserHooks in line with the Pythia8 protocol. Additionally, the macro should include a function to obtain a pointer to the custom UserHooks object.

---

### Replaying Steps and Optimizing Full Simulation Parameters

The `MCReplay` engine allows you to replay a simulation based on steps that were recorded by the `MCStepLogger` (refer to the [detailed documentation](https://github.com/AliceO2Group/VMCStepLogger/tree/v0.2.0/MCReplay) for more information).

To use it with the O2 framework, start by following the instructions in the [MCStepLoggerSection](#MCStepLoggerSection) to generate a file with logged steps. To replay these steps, execute the following command:
```bash
o2-sim-serial -n <ref_nevents> -e MCReplay -g extkinO2 --extKinFile o2sim_Kine.root -o replay
```
It is recommended to use a different output prefix, as shown here, to avoid overwriting hit files that contain crucial data. Ensure you include/exclude the same modules as in the reference run using the `-m` and `--skipModules` flags. If the reference run used a different prefix, the kinematics file name will be `<prefix>_Kine.root`.

---

## Digitization Step Documentation <a name="DigitSection"></a>

# Development

This section documents the digitization step, including the integration of the `UserHooksCharm` class, which is derived from `Pythia8::UserHooks`. The class is designed to veto parton-level events based on specific criteria. The `UserHooksCharm` constructor and destructor are default-defined. The `canVetoPartonLevel` method returns `true`, indicating the capability to veto parton-level events. The `doVetoPartonLevel` method iterates through the event particles, checking if the particle is a charm quark (id 4) and if its rapidity is within a specified range (|y| < 1.5). If these conditions are met, the event is vetoed; otherwise, it is allowed. The `pythia8_userhooks_charm` function returns a new instance of `UserHooksCharm`.

```cpp
Pythia8::UserHooks*
  pythia8_userhooks_charm()
{
  return new UserHooksCharm();
}
```

---

#### 3. **How can I run with the exact events used in an AliRoot simulation?**

You can perform any custom simulation with AliRoot and reuse the kinematics data stored in the `Kinematics.root` file. This file includes primary and secondary particles, which may have been added during transportation. If you pass this file to `o2sim`, the primary particles can be used as the initial event. Use the **`-g extkin`** command-line option:
```
o2-sim -g extkin --extKinFile Kinematics.root ...
```

#### 4. **How can I generate signal events using the vertex positions of pre-existing background events?**

---

```o2-ft0-digi2raw --configKeyValues "HBFUtils.orbitFirst=251" ...```

to initiate raw data generation starting from orbit 251 instead of the orbit 123 specified during the digitization process (i.e., the second TF of the run). An additional setting `HBFUtils.maxNOrbits` can be specified to constrain the number of orbits included (counted from the `SOX`) in the raw data (i.e., any data with `orbit > HBFUtils.orbitFirst + HBFUtils.maxNOrbits` will be excluded during the creation of the raw data).

---

| [sim_challenge.sh](../prodtests/sim_challenge.sh) | A basic example that performs a straightforward transport, digitization, and reconstruction pipeline across the entire detector. Each stage leverages parallelism. |
| [sim_performance.sh](../prodtests/sim_performance_test.sh) | A fundamental example showcasing a serial transport and a linearized digitization sequence, processing one detector at a time. It acts as a benchmark for performance. |

---

## Key new features in Run3 simulation compared to AliRoot

The Run3 simulation introduces the following enhancements:

  - **a distributed system based on FairMQ**, which splits event generation, particle transport, and IO into separate asynchronous components that can be deployed on different machines
  - **sub-event parallelism** that enables quick transport of a single large event and reduces memory usage
  - **independent parallelism** not tied to the transport engine
  - **configuration via predefined parameter classes and ini/text files**
  - **a clear separation of transport and digitization**, allowing each phase to be run independently

---

## Interaction Sampling <a name="Interaction sampling"></a>

The output files from `o2-sim` contain individual events without any time stamps. The digitization process will sample the vector of non-decreasing `{BC/orbit}` pairs based on the bunch filling pattern and the specified interaction rate, then pass them to the digitizers.
The interaction sampling is controlled by the `HBFUtils` configurable parameters, for example:

```o2-sim-digitizer-workflow --configKeyValues "HBFUtils.nHBFPerTF=128;HBFUtils.orbitFirst=123;HBFUtils.orbitFirstSampled=300"```

---

# Documentation of transport simulation <a name="SimSection"></a>

The `o2-sim` executable is designed to simulate particles produced in a collision event as they traverse through the detector, resulting in energy deposits (hits) that can potentially be translated into detectable signals. This is the main executable that initiates a network of subprocesses communicating through messages within a distributed computing environment.

## Usage Overview
* **Quick start example:** A standard (illustrative) command might look like:

    ```o2-sim -n 10 -g pythia8pp -e TGeant4 -j 2 --skipModules ZDC,PHS```

---

#### 5. **How can I retrieve comprehensive stepping data?** <a name="MCStepLoggerSection"></a>
To obtain detailed stepping information, run the simulation using `o2-sim-serial` with the following command:
```
MCSTEPLOG_TTREE=1 LD_PRELOAD=$MCSTEPLOGGER_ROOT/lib/libMCStepLoggerInterceptSteps.so o2-sim-serial -j 1 -n 10
```
This command generates a file named `MCStepLoggerOutput.root`, which includes detailed step and process data. This file can be analyzed using a dedicated analysis framework. For further details, see the documentation at https://github.com/AliceO2Group/VMCStepLogger/blob/master/README.md.

---

which would initiate a simulation of 10 pythia8 events across the entire ALICE detector, excluding the ZDC and PHOS, utilizing Geant4 on 2 parallel worker processes.
* **Generated output**: The simulation generates the following output files:

| File                  | Description                                                                            |
| --------------------- | -------------------------------------------------------------------------------------- |
| `o2sim_Kine.root`     | includes kinematics data (primaries and secondaries) and event metadata                |
| `o2sim_geometry.root` | contains the final ROOT geometry configured for the simulation run                    |
| `o2sim_grp.root`      | holds special global run parameters (grp), such as magnetic field                     |
| `o2sim_XXXHits.root`  | hit files for each active detector XXX involved in the simulation                      |

---

#### 7. **How can I modify medium parameters during a simulation?**
Certain medium parameters are set in `$O2/Detectors/<detector>/simulation/data/simcuts.txt` (or in `$O2/Detectors/Passive/data/simcuts_<modulename>.txt` for passive modules), while others may be hardcoded in the source. To inspect or alter these parameters dynamically, you can generate a `JSON` file using
```bash
o2-sim <args> --configKeyValues "MaterialManagerParam.outputFile=medium_params.json"
```
To adjust parameters of interest, modify `medium_params.json` and then use it as input for the simulation via
```bash
o2-sim <args> --configKeyValues "MaterialManagerParam.inputFile=medium_params.json"
```

**Note** that altering process parameters has no impact when Geant4 is employed for particle transport.

---

| --chunkSize | The size of a sub-event, which dictates how many primary tracks are dispatched to a simulation worker for processing. |
| --skipModules | A list of modules to exclude or skip, taking precedence over the -m option. |
| --configFile   | An `.ini` file with a list of (non-default) parameters to configure the simulation run. For more details, see the section on configurable parameters. |
| --configKeyValues | Similar to `--configFile`, but allows setting parameters directly on the command line as a string sequence. Example: `--configKeyValues "Stack.pruneKine=false"`. It takes precedence over `--configFile`. Parameters must be from the ConfigurableParams list. |
| --seed   | The initial seed for all random number generators. A default value of -1 results in random behavior. |
| -o,--outPrefix | The prefix for the output file. The default is o2sim. Example: `-o mySignalProduction`. |
| --noGeant | Disable Geant transport and only generate the generator kinematics. |

---

| [PrimaryKinematics](../run/SimExamples/JustPrimaryKinematics) | Example illustrating how to retrieve only primary kinematics using transport configuration |
| [HepMC_STARlight](../run/SimExamples/HepMC_STARlight) | Basic example demonstrating **generator setup** that executes an independent `STARlight` generation connected to `o2` through a `HepMC` file |
| [Jet_Embedding_Pythia](../run/SimExamples/Jet_Embedding_Pythia8) | Advanced example showcasing **generator setup**, **digitization embedding**, and **MCTrack accessibility** |
| [Selective_Transport](../run/SimExamples/Selective_Transport) | Simple example demonstrating how to run a simulation with transport limited to a customizable set of particles |
| [Selective_Transport_pi0](../run/SimExamples/Selective_Transport_pi0) | Advanced example illustrating the use of inhibit-pause-trigger-continue method in a simulation run |
| [Custom_EventInfo](../run/SimExamples/Custom_EventInfo) | Simple example demonstrating how to include custom data in the MC event header |

---

If the positional correspondence is too weak, an alternative approach is to store the corresponding data index in the label container within the digit itself:
```c++
const auto& digit = mDigits[pos];
// provides an iterable view of labels
const auto& labels_for_digit = mLabelContainer.getLabels(digit.labelindex);
// iterate through labels
for (auto& label : labels_for_digit) {
   // process label
}
```


## Accessing Monte Carlo Kinematics<a name="MCReader"></a>

Following the digitization process, the `MCKinematicsReader` class can be utilized to load and access the Monte Carlo tracks. This class requires the digitization context file, which is generated during the digitization step. After initialization, it can provide access to the tracks linked to a Monte Carlo label.

A typical code example might look like:
```c++
// initialize the reader using the context
o2::steer::MCKinematicsReader reader("collisioncontext.root");
```

---

<!-- doxy
\page refdocDetectorSimulation Detector Simulation
/doxy -->

# Documentation for Detector Simulation

This document provides details about the ALICE detector simulation and digitization procedures utilized in LHC Run3.

## Overview

Detector simulation, which simulates detector responses to virtual particle events, comprises two primary components:
  a) generating simple (energy deposit) traces within the detector as particles pass through and interact with the detector material.
  b) converting these traces into (electronic) signals for the detector readout (typically referred to as digitization).

The first component is managed by the `o2-sim` executable (refer to [SimSection](#SimSection)). The second component is handled by the `o2-sim-digitizer-workflow` executable (refer to [DigitSection](#DigitSection)). Additional examples are [listed here](#Examples).

## Key New Features Compared to AliRoot

The Run3 simulation introduces the following advancements:

The paraphrased document retains the original meaning and structure while using different wording.

---

Important factors that shape the transport simulation include:

| Key Parameter | Description |
| --- | --- |
| G4 | Settings that affect the Geant4 engine, like the physics list. For instance, "G4.physicsmode=kFTFP_BERT_optical_biasing" |
| Stack | Settings that affect the particle stack. Examples include whether kinematics pruning is done and if secondaries are retained. |
| SimCutParams | Allows setting geometry stepping cuts in R, Z, and other dimensions. |
| Diamond | Sets the interaction vertex location and its spread/width, used across all event generators. |
| Pythia8 | Parameters impacting the Pythia8 generator. |
| HepMC | Parameters impacting the HepMC generator. |
| TriggerParticle | Influences the trigger mechanism in particle generators. |

Detectors can also have parameters that affect aspects like geometry layout and material composition.

## Guidance on available generators

---

If the name of the step log file varies, you can specify it using `--configKeyValues="MCReplayParam.stepFilename=<path/step/file/name>"`. Additionally, you can define a minimum energy threshold (in GeV) for particles, where those produced below this threshold will be excluded. To do this, apply `--configKeyValues="MCReplayParam.energyCut=0.1"` if you want to discard particles with an energy below `0.1 GeV`.

To improve efficiency and speed, you can omit steps or particle production that have a minimal effect on the hits and consequently on the digits when comparing with a reference run. This adjustment allows the detector simulation to run more efficiently.

---

The procedure is as follows: For a group of digits allocated for detector `foo`
```c++
std::vector<o2::foo::Digits> mDigits;
```
we maintain an additional container for labels of type:
```c++
o2::dataformats::MCTruthContainer<o2::dataformats::MCCompLabel> mLabelContainer;
```
Accessing the labels is done through positional correspondence: Labels for the digit at position `pos` can be retrieved as follows:
```c++
const auto& digit = mDigits[pos];
// provides an iterable view of labels
const auto& labels_for_digit = mLabelContainer.getLabels(pos);
// iterate over the labels
for (auto& label : labels_for_digit) {
   // process the label
}
```

---

* **Generated output**: The digitization process produces the following output files:

| File                  | Description                                                                            |
| --------------------- | -------------------------------------------------------------------------------------- |
| `collisioncontext.root` | Holds details about the collision/digitization context utilized in this digitization. It includes the list of input files, the composition of collisions for the digit embedding process, and timestamps assigned.  |
| `XXXdigits.root` | Usually one digit file per detector XXX in a timeframe format. This file also generally contains mappings of digit indices to MC labels. |
| `o2simdigitizerworkflow_configuration.ini` | Summarizes the parameters used during the digitization process. |


* **Main command line options**: The following significant options are available:

---

In order to accommodate various types of event generators, which are generally independent of each other, a `void*` must be utilized. The name includes a string that indicates the specific generator, allowing for the appropriate type casting to be applied.

---

This feature could be beneficial for users aiming to control the event-generation process deeply within the internal routines and to veto particular processes by analyzing the status of Pythia8 at different stages, such as vetoing events that lack charm partons prior to the hadronisation of partons. This can reduce the time required for event generation by skipping many steps early on.

An example of a configuration macro is as follows:

```
//   usage: o2sim -g pythia8pp --configKeyValues "GeneratorPythia8.hooksFileName=pythia8_userhooks_charm.C"

#include "Generators/Trigger.h"
#include "Pythia8/Pythia.h"
```

---

It is important to note that for detectors operating in continuous readout mode, empty HBFs will be generated for all orbits without detector data between the `SOX` and the final orbit of the TF that contains received data. If you wish to start creating raw data from the first sampled TF, you can modify `HBFUtils.orbitFirst` to the desired orbit. For instance, as shown in the example above, one could set

This maintains the same meaning and length as the original text.

---

## F.A.Q.
You can contribute to the documentation by posing a question.

#### 1. **How do I connect an external event generator with ALIROOT?**
To utilize event generators like `THijing` or `TPyhtia6` from ALIROOT, you can use the `-g external` command-line parameter, coupled with a ROOT macro that sets up the event generator. Examples of such macros are found in the installation directory `$O2_ROOT/share/Generators/external`. Users can also create their own macros to tailor the setup to their specific requirements.

#### 2. **How can I run the simulation on a specific subset of geometry modules?**
Employ the `--modules` or `-m` command-line option. For instance, `o2-sim -m PIPE ITS TPC` will simulate the geometry and material comprising PIPE, ITS, and TPC.

#### 3. **How can I ensure the simulation generates the same events as an AliRoot simulation?**
Run the simulation with the exact configuration and parameters used in the AliRoot simulation.

---

| `o2sim_configuration.ini` | summary of the parameter settings used in the simulation |
| `o2sim_serverlog` | log file generated by the particle generator server |
| `o2sim_workerlog` | log file created by the transportation processes |
| `o2sim_hitmergerlog` | log file from the IO process operations |

---

* **Key command line options**: The document lists several primary options (incomplete):

    PARAPHRASED DOCUMENT: * **Principal command line parameters**: The following significant options are provided (incomplete):

---

// load digits from the digits file and store them in alldigits
// load the label container from the digits file and save it in labelcontainer

// the code iterates over all the digits and retrieves the tracks that contributed to each digit

for (int pos = 0; pos < alldigits.size(); ++pos) {
  const auto& digit = alldigits[pos];
  const auto& labels_for_digit = labelcontainer.getLabels(pos);
  // loop through the labels
  for (auto& label : labels_for_digit) {
     track = reader.getTrack(label);
     // perform actions with the track
  }
}
```
Note that one can also access kinematics directly after the transport simulation. 
To do so, initialize the MCKinematicsReader in a different mode:
```c++
// initialize the reader from the transport kinematics file (assuming the prefix is o2sim)
o2::steer::MCKinematicsReader reader("o2sim", o2::steer::MCKinematicsReader::Mode::kMCKine);
```