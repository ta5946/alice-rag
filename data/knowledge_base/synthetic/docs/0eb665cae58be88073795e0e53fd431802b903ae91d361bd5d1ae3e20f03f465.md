## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/test/run_workflow_tests.sh

**Start chunk id:** 0eb665cae58be88073795e0e53fd431802b903ae91d361bd5d1ae3e20f03f465

## Content

# flag to indicate if any changes occurred in the simulation workflow binary directory
changed_sim_bin=$(git_get_changed_files | grep -E "MC/bin")
# check for changes related to AnalysisQC
changed_analysis_qc=$(git_get_changed_files | grep -E "MC/analysis_testing|MC/config/analysis_testing/json|MC/config/QC/json")
# verify if any changes are related to anchoring
changed_anchored=$(git_get_changed_files | grep -E "MC/bin|MC/run/ANCHOR/anchorMC.sh|MC/run/ANCHOR/tests|MC/bin|UTILS/parse-async-WorkflowConfig.py|DATA/production/configurations/asyncReco/setenv_extra.sh|DATA/production/configurations/asyncReco/async_pass.sh|DATA/common/setenv.sh|DATA/production/workflow-multiplicities.sh")
# initialize variable for workflow scripts changes
changed_workflows=
# define workflows to be executed
execute_workflows=
echo "==> Test outline"
if [[ "${changed_sim_bin}" != "" ]] ; then
    # if changes exist in the central binaries, test the creation of all workflows against these changes

---

# In this scenario, a central component has been altered, so it's necessary to test all simulation workflows against it.
echo "  - All simulation workflows derived from run scripts (MC/run/**/*.sh) will be tested for creation."
for p in $(find MC/run -name "*.sh") ; do
    changed_workflows+="$(realpath ${p}) "
done
# If central Python scripts have been modified, mark the anchored MC test to be executed.
echo "    - Detection of changes in MC/bin, mark anchored MC test for execution."
changed_anchored="1"
else
    # Otherwise, only consider the changed shell scripts.
    changed_workflows=
    changed_files=$(git_get_changed_files)
    for cf in ${changed_files} ; do
        [[ "${cf}" != *"MC/run"*".sh" ]] && continue
        changed_workflows+="${cf} "
    done
    [[ "${changed_workflows}" != "" ]] && echo "  - Simulation workflows from changed run scripts (subset of MC/run/**/*.sh) will be tested."
fi

---

if [[ "${changed_analysis_qc}" != "" || "${changed_sim_bin}" ]] ; then
    for p in $(find "MC/bin/tests" -name "*.sh") ; do
        execute_workflows+="$(realpath ${p}) "
    done
    echo "  - Verify AnalysisQC CLI operation using simulation."
fi

[[ "${changed_anchored}" != "" ]] && echo "  - Test anchored simulation."

# gather all components, then return to the previous directory
popd > /dev/null
REPO_DIR=$(realpath ${REPO_DIR})

# perform the following procedure:
# utilize the source directory since O2DPG's installation is essentially a copy of the entire repository.
# This approach is particularly suitable for local testing and functions similarly in the CI environment. Alternatively, we could execute
#         [[ -z {ALIBUILD_HEAD_HASH+x} ]] && export O2DPG_ROOT=${REPO_DIR}
# but let's maintain consistency for both local and CI testing
export O2DPG_ROOT=${REPO_DIR}


##############################
# PWG workflow shell scripts #
##############################
# overall return code for PWGs
ret_global_pwg=0

---

[[ "${ret_this}" == "0" ]] && { ${O2DPG_ROOT}/MC/bin/o2_dpg_workflow_runner.py -f workflow.json --cpu-limit 8 --target-labels Analysis ${memlimit} -k >> ${LOG_FILE_WF} 2>&1 ; ret_this_analysis=${?} ; }
ret_this=$((ret_this + ret_this_qc + ret_this_analysis))
[[ "${ret_this}" != "0" ]] && echo "[FATAL]: O2DPG_TEST Workflow execution failed" >> ${LOG_FILE_WF} || echo_green " -> PASSED"
else
    echo_green " -> PASSED"
fi
return ${ret_this}
}

---

test_single_wf()
{
    local wf_script=${1}
    local execute=${2}
    make_wf_creation_script ${wf_script} ${wf_script_local}
    local has_wf_script_local=${?}
    echo -n "Test ${TEST_COUNTER}: ${wfs}"
    if [[ "${has_wf_script_local}" != "0" ]]; then
        echo -n " (No WF creation in script)"
        echo_red " -> FAILED"
        return 1
    fi
    # Check for any "exit" command apart from the typical one
    # [ ! "${O2DPG_ROOT}" ] && echo "Error: This needs O2DPG loaded" && exit 1
    # This is not ideal but could help avoid running into checks the WF script performs before launching the WF creation
    if [[ "$(grep exit ${wf_script_local} | grep -v "This needs")" != "" ]]; then
        echo -n " (Found \"exit\" in script, not testing automatically)"
        echo_yellow " -> WARNING"
        return 0
    fi
    # Execute a single test
    echo "Test ${wf_line} from ${wfs}" > ${LOG_FILE_WF}
    bash ${wf_script_local} >> ${LOG_FILE_WF} 2>&1
    local ret_this=${?}
    local ret_this_qc=0
}

---

#!/bin/bash

# Define the test parent directory to be created in the current directory
TEST_PARENT_DIR_PWG="o2dpg_tests/workflows_pwgs"
TEST_PARENT_DIR_BIN="o2dpg_tests/workflows_analysisqc"
TEST_PARENT_DIR_ANCHORED="o2dpg_tests/anchored"

# Unified names for log files
LOG_FILE_WF="o2dpg-test-wf.log"
LOG_FILE_ANCHORED="o2dpg-test-anchored.log"
LOG_FILE_ANALYSISQC="o2dpg-test_analysisqc.log"


get_git_repo_directory()
{
    local directory_to_check=${1:-$(pwd)}
    directory_to_check=$(realpath "${directory_to_check}")
    directory_to_check=${directory_to_check%%/.git}
    local repository_path=
    (
        cd "${directory_to_check}"
        repository_path=$(git rev-parse --git-dir 2> /dev/null)
        [[ "${repository_path}" != "" ]] && { repository_path=$(realpath "${repository_path}") ; repository_path=${repository_path%%/.git} ; }
    )
    echo ${repository_path}
}

---

test_analysisqc_cli()
{
    ((TEST_COUNTER++))
    local test_dir="${TEST_COUNTER}_analysisqc_cli"
    rm -rf ${test_dir} 2> /dev/null
    mkdir ${test_dir}
    pushd ${test_dir} > /dev/null
        echo "### Testing AnalysisQC creation for MC ###" > ${LOG_FILE_ANALYSISQC}
        echo -n "Test ${TEST_COUNTER}: Running AnalysisQC CLI"
        ${O2DPG_ROOT}/MC/analysis_testing/o2dpg_analysis_test_workflow.py -f AO2D.root --is-mc -o workflow_test_mc.json >> ${LOG_FILE_ANALYSISQC} 2>&1
        local ret=${?}
        [[ "${ret}" != "0" ]] && echo "[FATAL]: O2DPG_TEST failed" >> ${LOG_FILE_ANALYSISQC}
        echo "### Testing AnalysisQC creation for data ###" >> ${LOG_FILE_ANALYSISQC}
        ${O2DPG_ROOT}/MC/analysis_testing/o2dpg_analysis_test_workflow.py -f AO2D.root -o workflow_test_data.json >> ${LOG_FILE_ANALYSISQC} 2>&1
        local ret_data=${?}
        [[ "${ret_data}" != "0" ]] && { echo "[FATAL]: O2DPG_TEST failed" >> ${LOG_FILE_ANALYSISQC} ; ret=${ret_data} ; }

}

---

# navigate back to the previous directory
popd > /dev/null
fi


###############
# ANCHORED MC #
###############
# overall return code for PWGs
ret_global_anchored=0
if [[ "${changed_anchored}" != "" ]] ; then
    # create the local test directory for PWG tests
    rm -rf ${TEST_PARENT_DIR_ANCHORED} 2>/dev/null
    mkdir -p ${TEST_PARENT_DIR_ANCHORED} 2>/dev/null
    pushd ${TEST_PARENT_DIR_ANCHORED} > /dev/null

    echo
    echo "==> START BLOCK: Execute anchored simulation"
    # perform an anchored test
    test_anchored
    ret_global_anchored=${?}
    [[ "${ret_global_anchored}" != "0" ]] && { echo "ERROR during anchored simulation." ;  print_error_logs ./ ; }
    echo "==> END BLOCK: Execute anchored simulation"

    # return to the previous directory
    popd > /dev/null
fi

RET=$(( ret_analysis_qc + ret_global_anchored ))

echo
[[ "${RET}" != "0" ]] && echo_red "Errors detected, please review!" || echo_green "All workflow tests completed successfully"

exit ${RET}

---

DOCUMENT:
    test_anchored()
    {
        local to_run="${1:-${O2DPG_ROOT}/MC/run/ANCHOR/tests/test_anchor_2023_apass2_pp.sh}"
        local RET=0
        for anchored_script in ${to_run} ; do
            if [[ ! -f ${anchored_script} ]] ; then
                echo "The desired test script ${anchored_script} does not exist. Skip." 
                continue
            fi
            ((TEST_COUNTER++))
            local test_dir=${TEST_COUNTER}_$(basename ${anchored_script})_dir
            rm -rf ${test_dir} 2> /dev/null
            mkdir ${test_dir}
            pushd ${test_dir} > /dev/null
                echo -n "Test ${TEST_COUNTER}: ${anchored_script}"
                ${anchored_script} >> ${LOG_FILE_ANCHORED} 2>&1
                local ret_this=${?}
                if [[ "${ret_this}" != "0" ]] ; then
                    echo_red " -> FAILED"
                    RET=${ret_this}
                else
                    echo_green " -> PASSED"
                fi
            popd > /dev/null
        done
        return ${RET}
    }

    print_usage()
    {

---

DOCUMENT:
    #############
# Main Part #
#############
while [ "$1" != "" ] ; do
    case $1 in
        --help|-h )          print_usage
                             exit 1
                             ;;
        * )                  echo "Unknown argument ${1}"
                             exit 1
                             ;;
    esac
done

# Determine the repository directory
REPO_DIR=${O2DPG_TEST_REPO_DIR:-$(get_git_repo_directory)}
if [[ ! -d ${REPO_DIR}/.git ]] ; then
    echo "ERROR: Directory \"${REPO_DIR}\" is not a git repository."
    exit 1
fi

if [[ -z ${O2DPG_ROOT+x} ]] ; then
    echo "ERROR: O2DPG is not loaded, indicating that other packages are likely missing in this environment."
    exit 1
fi

# Source the utilities
source ${REPO_DIR}/test/common/utils/utils.sh


echo "##############################"
echo "# Execute O2DPG workflow tests#"
echo "##############################"

# Perform the initial actions in the source directory, where the complete git repository is available
pushd ${REPO_DIR} > /dev/null

---

DOCUMENT:
    popd > /dev/null
    [[ "${ret}" != "0" ]] && echo_red " -> FAILED" || echo_green " -> PASSED"
    return ${ret}
}

---

echo
echo "  SPECIFIC ENVIRONMENT VARIABLES FOR THIS TEST:"
echo "  O2DPG_TEST_WORKFLOW_MEMLIMIT : The memory limit to be provided to the workflow runner when a workflow is executed (optional)"
echo
}

---

run_workflow_creation()
{
    local wf_scripts=
    local execute=
    while [ "$1" != "" ] ; do
        case $1 in
            --execute ) execute=1
                        shift
                        ;;
            * )         wf_scripts+="${1} "
                        shift
                        ;;
        esac
    done

    local RET=0
    local wf_script_local="wf.sh"

    for wfs in ${wf_scripts} ; do
        local wf_line=$(get_workflow_creation_from_script ${wfs})
        [[ "${wf_line}" == "" ]] && continue

        ((TEST_COUNTER++))
        local test_dir=${TEST_COUNTER}_$(basename ${wfs})_dir
        rm -rf ${test_dir} 2> /dev/null
        mkdir ${test_dir}
        pushd ${test_dir} > /dev/null
            test_single_wf ${wfs} ${execute}
            local ret_this=${?}
            [[ "${ret_this}" != "0" ]] && RET=${ret_this}
        popd > /dev/null
    done

    return ${RET}
}

---

# return to the previous directory
popd > /dev/null
fi


####################################
# sim workflow bin with AnalysisQC #
####################################
# prepare our local test directory for bin tests
# global return code for PWGs
ret_analysis_qc=0
if [[ "${changed_analysis_qc}" != "" ]] ; then
    rm -rf ${TEST_PARENT_DIR_BIN} 2>/dev/null
    mkdir -p ${TEST_PARENT_DIR_BIN} 2>/dev/null
    pushd ${TEST_PARENT_DIR_BIN} > /dev/null

    echo
    echo "==> START BLOCK: Executing workflow with AnalysisQC <=="
    # test command line interface
    test_analysisqc_cli
    ret_analysis_qc=${?}
    # Run all the bin test WF creations
    if [[ "${ret_analysis_qc}" -eq 0 ]]; then
        run_workflow_creation ${execute_workflows} --execute
        ret_analysis_qc=${?}
    fi
    if [[ "${ret_analysis_qc}" -ne 0 ]]; then
        echo "ERROR for workflows execution and AnalysisQC."
        print_error_logs ./ ;
    fi
    echo "==> END BLOCK: Executing workflow with AnalysisQC <=="

    # return to the previous directory
    popd > /dev/null

---

bash ${wf_script_local} >> ${LOG_FILE_WF} 2>&1
local ret_this=${?}
local ret_this_qc=0
local ret_this_analysis=0
if [[ "${ret_this}" != "0" ]] ; then
    echo_red " -> FAILED"
    echo "[FATAL]: O2DPG_TEST Workflow creation failed" >> ${LOG_FILE_WF}
elif [[ "${execute}" != "" ]] ; then
    local memlimit=${O2DPG_TEST_WORKFLOW_MEMLIMIT:+--mem-limit ${O2DPG_TEST_WORKFLOW_MEMLIMIT}}
    ${O2DPG_ROOT}/MC/bin/o2_dpg_workflow_runner.py -f workflow.json --cpu-limit 8 -tt aod ${memlimit} >> ${LOG_FILE_WF} 2>&1
    ret_this=${?}
    # use -k|--keep-going option to continue running even after the first failure, allowing to see if there are more issues
    [[ "${ret_this}" == "0" ]] && { ${O2DPG_ROOT}/MC/bin/o2_dpg_workflow_runner.py -f workflow.json --cpu-limit 8 --target-labels QC ${memlimit} -k >> ${LOG_FILE_WF} 2>&1 ; ret_this_qc=${?} ; }

---

DOCUMENT:
    echo
    echo "usage: run_workflow_tests.sh"
    echo
    echo "  ENVIRONMENT VARIABLES TO DETERMINE WHAT TO COMPARE:"
    echo
    echo "  O2DPG_TEST_REPO_DIR : Specify the source repository you want to test."
    echo "  O2DPG_TEST_HASH_BASE : The base hash for comparison (optional)"
    echo "  O2DPG_TEST_HASH_HEAD : The head hash for comparison (optional)"
    echo
    echo "  If O2DPG_TEST_HASH_BASE is not defined, it will be checked for ALIBUILD_BASE_HASH."
    echo "  If ALIBUILD_BASE_HASH is not found, it will be set to HEAD~1, or HEAD if there are unstaged changes."
    echo
    echo "  If O2DPG_TEST_HASH_HEAD is not defined, it will be checked for ALIBUILD_HEAD_HASH."
    echo "  If ALIBUILD_HEAD_HASH is not found, it will be set to HEAD, or left blank if there are unstaged changes."
    echo
    echo "  SPECIFIC ENVIRONMENT VARIABLES FOR THIS TEST:"

---

# Verify the changes
if [[ "${changed_workflows}" != "" ]] ; then
    # set up a local testing directory for PWG tests
    rm -rf ${TEST_PARENT_DIR_PWG} 2>/dev/null
    mkdir -p ${TEST_PARENT_DIR_PWG} 2>/dev/null
    pushd ${TEST_PARENT_DIR_PWG} > /dev/null

    echo
    echo "==> START BLOCK: Validate PWG-related workflow generation <=="
    run_workflow_creation ${changed_workflows}
    ret_global_pwg=${?}
    [[ "${ret_global_pwg}" != "0" ]] && { echo "WARNING for workflow generation, some might not have been created." ;  print_error_logs ./ ; }
    echo "==> END BLOCK: Validate PWG-related workflow generation <=="

    # restore the original directory
    popd > /dev/null
fi