## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/UTILS/parse-async-WorkflowConfig.py

**Start chunk id:** 0cf57bed705c45e7a809d86177775fdfaa0218fc7a728e91c1e0db40e20dfa31

## Content

# gpu/tpc tracking
  if the command is 'o2-gpu-reco-workflow':
     c = {}
     c['gpu-reconstruction'] = extract_args(tokens, '--gpu-reconstruction')
     flat_config[cmd + '-options'] = c

  # itstpc matching
  if the command is 'o2-tpcits-match-workflow':
     correction_string = ''
     s1 = extract_args(tokens, '--lumi-type')
     if s1:
        correction_string += ' --lumi-type ' + s1
     s2 = extract_args(tokens, '--corrmap-lumi-mode')
     if s2:
        correction_string += ' --corrma-lumi-mode ' + s2
     # these options are used in several places, so store them directly under tpc-corr-scaling
     flat_config['tpc-corr-scaling'] = correction_string

  # hmp matching
  if the command is 'o2-hmpid-matcher-workflow':
     c = {}
     c['track-sources'] = extract_args(tokens, '--track-sources')
     flat_config['o2-hmpid-matcher-workflow'] = c

---

def extract_detector_list():
   """
   retrieves the list of sensitive detectors utilized
   """

def extract_config_key_values(tokenlist):
   kvconfig = {}
   for i, t in enumerate(tokenlist):
       if t == '--configKeyValues':
           configs = tokenlist[i+1]
           # individual key-values:
           if configs[0] == '"':
               configs = configs[1:]
           if configs[-1] == '"':
               configs = configs[:-1]
           keyvals = configs.split(";")
           for kv in keyvals:
               tmp = kv.rstrip().split("=")
               if len(tmp) > 1:
                   key = tmp[0]
                   value = tmp[1]
                   kvconfig[key] = value
   return kvconfig

def extract_args(tokens, arg):
   """
   retrieves the value for a specified argument from a list of argument tokens
   """
   i = 0
   while i < len(tokens):
       t = tokens[i]
       if t == arg:
           return tokens[i+1] if i+1 < len(tokens) else ""
       i += 1
   return ""

---

DOCUMENT:
    def print_untreated_args(cmds):
        """
        let's display the content of remaining_args
        """
        for task in cmds:
            rargs = task.get("remainingargs")
            if rargs and len(rargs) > 0:
                print(task["cmd"], " ", rargs)


def print_principalconfigkeys_pertask(cmds):
    """
    outputs the list of principal configuration keys for each task
    """
    for task in cmds:
        c = task.get("configval")
        if c is not None:
            keyset = set()
            for k in c:
                keyset.add(k.split(".")[0])
            print(task["cmd"], " ", keyset)


def split_string_with_quotes(string):
    # function to split a string into tokens on whitespace, but only
    # if whitespace is not within a quoted section
    pattern = r'\s+(?=(?:[^\'"]*[\'"][^\'"]*[\'"])*[^\'"]*$)'
    # Split the string using the pattern
    tokens = re.split(pattern, string)
    return tokens

---

#!/usr/bin/env python3

# A script to parse configuration
# from a reco workflow for application in MC. Outputs a JSON with the configuration.

# Things to parse:
# - detector list
# - components of the reco workflow
# - vertexing sources and other components
# - configuration parameters per job
# - can produce a JSON or a dictionary

import re
import json
import os

def get_topology_cmd(filename):
   """
   Returns the command for the topology from a workflow filename.
   """
   with open(filename, 'r') as f:
       lines = f.readlines()
   output = []
   for l in lines:
       if '--session' in l and "o2-" in l:
           output.append(l)
   return output

def extract_detector_list():
   """
   Extracts the list of sensitive detectors used.
   """

---

# aod
if cmd == 'o2-aod-producer-workflow':
    c = {}
    c['info-sources'] = extract_args(tokens, '--info-sources')
    flat_config[cmd + '-options'] = c

# its reco
if cmd == 'o2-its-reco-workflow':
    pass

# trd tracking
if cmd == 'o2-trd-global-tracking':
    c = {}
    c['track-sources'] = extract_args(tokens, '--track-sources')
    flat_config[cmd + '-options'] = c

# tof matching
if cmd == 'o2-tof-matcher-workflow':
    c = {}
    c['track-sources'] = extract_args(tokens, '--track-sources')
    flat_config[cmd + '-options'] = c

# ctf reader workflow (this allows us to restrict
# sensitive detectors and streamline the overall graph workflow)
if cmd == 'o2-ctf-reader-workflow':
    c = {}
    c['onlyDet'] = extract_args(tokens, '--onlyDet')
    flat_config[cmd + '-options'] = c

---

tokens = remove_tokens(tokens,"--loop", 2)
    tokens = remove_tokens(tokens,"--early-forward-policy", 2)
    tokens = remove_tokens(tokens,"--fairmq-rate-logging", 2)
    tokens = remove_tokens(tokens,"--pipeline", 2)
    tokens = remove_tokens(tokens,"--disable-mc", 1)
    tokens = remove_tokens(tokens,"--disable-root-input", 1)

---

def extract_commands(commandlist):
    commands = []
    for l in commandlist:
        task = {}
        # each l is a standalone command piped together
        l = l.rstrip('\n')
        l = l.rstrip()
        l = l.rstrip('|')
        tokens = split_string_with_quotes(l)
        # remove unnecessary elements
        tokens = remove_tokens(tokens,'', 1)
        tokens = remove_tokens(tokens,'\n', 1)
        tokens = remove_tokens(tokens,'|', 1)
        tokens = remove_tokens(tokens,'\\\n', 1)
        tokens = remove_tokens(tokens,"--session", 2)
        tokens = remove_tokens(tokens,"--severity", 2)
        tokens = remove_tokens(tokens,"--shm-segment-id", 2)
        tokens = remove_tokens(tokens,"--shm-segment-size", 2)
        tokens = remove_tokens(tokens,"--resources-monitoring", 2)
        tokens = remove_tokens(tokens,"--resources-monitoring-dump-interval", 2)
        tokens = remove_tokens(tokens,"--delay", 2)
        tokens = remove_tokens(tokens,"--loop", 2)

---

DOCUMENT:
    cmdlist = retrieve_topology_commands("workflowconfig.log")
    #print (cmdlist)
    cmds = extract_commands(cmdlist)
    # print_untreated_args(cmds)
    print_principalconfigkeys_pertask(cmds)
    flat_config = flatten_config_values(cmds)
    #print (flat_config)
    postadjust_ConfigValues(flat_config)
    parse_important_DPL_args(cmds, flat_config)
    configValues_to_json(flat_config)

---

def filter_tokens(tokens, exclude, step=1):
    # eliminate tokens that match the specified argument
    filtered_tokens = []
    index = 0
    while index < len(tokens):
        token = tokens[index]
        if token == exclude:
            index += step
            continue
        filtered_tokens.append(token)
        index += 1
    return filtered_tokens

---

DOCUMENT:
    cmd = tokens[0]
    tokens = tokens[1:len(tokens)]
    task['cmd'] = cmd
    # we check for a list of special settings

    # config-params
    task['configval'] = extract_config_key_values(tokens)
    tokens = remove_tokens(tokens,"--configKeyValues", 2)

    # we save the remaining options for further processing
    task['remainingargs'] = tokens
    commands.append(task)

   return commands

# some manual adjustments (could and should be performed externally)
def postadjust_ConfigValues(flat_config):
  gpuglobal = flat_config.get("GPU_global")
  # correct the path for TPC root files
  d=os.getcwd()
  for key in gpuglobal:
      if gpuglobal[key].count(".root") > 0:
         gpuglobal[key] = d + "/" + gpuglobal[key]

---

# convert configuration values to INI format
def configValues_to_ini(flatconfig):
    """
    It appears that there is supposed to be an INI conversion function, but its location is uncertain.
    Therefore, we are implementing this functionality here.
    """
    # create and write to INI file
    with open("ini-file", "w") as f:
        for mainkey in flatconfig:
            f.write(f"[{mainkey}]\n")
            for subkey in flatconfig[mainkey]:
                f.write(f"{subkey}={flatconfig[mainkey][subkey]}\n")

def configValues_to_json(flatconfig):
    """
    """
    with open('config-json.json', 'w') as outfile:
        json.dump(flat_config, outfile, indent=2)


def parse_important_DPL_args(cmds, flat_config):
    """
    In this function, we handle key arguments that are not part of the configuration parameters, such as --vertexing-sources and --vertex-track-matching sources, which are specific to reconstruction tasks.
    We cannot simply use all arguments, as some are specific to the reconstruction process, so we need to keep a list of these.
    """

---

The options are tied to the same configuration as the configurable parameters ... under specific keys that can be accessed during the MC workflow creation.

The script processes the `cmds` dictionary and updates the `flat_config` dictionary.
"""

For each task in `cmds`, the script processes it by specific tasks until a more efficient method is implemented.
The command and its remaining arguments are extracted as `cmd` and `tokens`, respectively.
For the primary vertex finder, which requires "vertexing sources and vertex-track-matching-sources", the script does the following:
A new dictionary `c` is created, where `c['vertexing-sources']` is set to the arguments extracted with `--vertexing-sources`, and `c['vertex-track-matching-sources']` is set to the arguments extracted with `--vertex-track-matching-sources`. This dictionary is then added to `flat_config` under the key `cmd + '-options'`.

For the secondary vertex finder, a similar process is followed, creating a dictionary `c` where `c['vertexing-sources']` is set to the arguments extracted with `--vertexing-sources`, and this dictionary is added to `flat_config` under the key `cmd + '-options'`.

---

def flatten_config_values(commandlist):
    """
    Let's check for any duplicates or contradictions and try to generate a flat dictionary of configuration values.
    """
    main_sub_config = {}
    for task in commandlist:
        thisconfig = task.get('configval')
        if thisconfig:
            for compoundkey in thisconfig:
                mainkey = compoundkey.split(".")[0]
                subkey = compoundkey.split(".")[1]
                if not main_sub_config.get(mainkey):
                    main_sub_config[mainkey] = {}
                prev_value = main_sub_config[mainkey].get(subkey)
                current_value = thisconfig[compoundkey]
                if prev_value and prev_value != current_value:
                    print("Found conflicting duplicate key .. cannot flatten directly")
                else:
                    main_sub_config[mainkey][subkey] = current_value
    return main_sub_config