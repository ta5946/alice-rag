## Metadata

**Document link:** https://github.com/AliceO2Group/AliceO2/blob/dev/Common/SimConfig/doc/ConfigurableParam.md

**Start chunk id:** 34f912be5f8cab9948fcd8579d10675e2aa7104cdf7abf867585a4209c3d2df7

## Content

# Desired enhancements / upcoming improvements

* Provide a more adaptable method for specifying array types (to represent them in strings), such as:
  ```c++
  ConfigurableParam::fromString("ParamA.array = {5, 6, 7}");
  ```
* Enhance the flexibility of CCDB reading, allowing either:
  * reading from a full snapshot via a single file name **or**
  * reading from multiple files in paths that match the key/namespace.
* Introduce a more flexible serialization method, for example, the ability to output configuration to different files.
* Enable changing the configuration from a text file, in addition to the current option via the command line.
* Add support for several key STL containers (std::array, std::vector).
* Develop a more versatile way to define stages (CODE, CCDB, RT) and facilitate transitions between them, possibly allowing for additional stages.
* Reduce boilerplate by automatically generating dictionaries for parameter classes.

---

```c++
ConfigurableParam::fromString("A.p2=10,OtherParam.a=-1.");
```
The system will issue a warning if an undefined string key is utilized.

* serialize the configuration into a ROOT snapshot or into formats like JSON or INI
  ```c++
  ConfigurableParam::toINI(filename);
  ConfigurableParam::toJSON(filename); // JSON representation of param registry
  ConfigurableParam::toCCDB(filename); // CCDB snapshot of param registry
  ```
* extract parameters from a CCDB snapshot
  ```c++
  ConfigurableParam::fromCCDB(filename);
  ```
* **Provenance tracking**: The system maintains a record of the origin of values. Generally, modifications can occur through:
  - default parameter initialization from code (CODE)
  - initialization or overwriting from a CCDB snapshot file
  - runtime user overrides (RT)

---

<!-- doxy
\page refCommonSimConfig SimConfig
/doxy -->

# Configurable Parameters

This README provides a brief overview of configurable parameters using the ConfigurableParameter class.

# Introduction

The ConfigurableParameter class addresses the need for:
* simple variables, under a compound namespace, to be treated as 'knobs' of an algorithm, allowing their values to be modified without recompilation.
* these variables to be automatically registered in a parameter database or manager instance.
* the ability to configure or change parameter values through a textual interface, such as from the command line.
* support for automatic serialization and deserialization techniques, like loading from CCDB or passing parameter snapshots to other processing stages.
* maintaining a record of who made changes to parameters (provenance tracking).

# Example / HowTo:

---

// interact with the parameters in your code
   doSomething(pa.p1, pa.p2);
 }
 
Subsequently, the parameter `ParamA` is automatically registered in a parameter registry and can be accessed/moderated/serialized via this registry. The principal functions for modulation are static methods within the `ConfigurableParam` class. For instance, you can:
* retrieve a value using a string key, pointing to a particular parameter:
  ```c++
   auto p = ConfigurableParam::getValue<double>("A.p2");
  ```
  where the string keys are formed by combining a primary key and the parameter variable name.
* adjust or set a value using a string key
  ```c++
  ConfigurableParam::setValue<double>("A.p2", 10);
  ```
  again, with string keys made up of a primary key and the parameter variable name.
  Note: This API enables you to modify values based on strings, such as those derived from command line inputs:
  ```c++
  ConfigurableParam::fromString("A.p2=10,OtherParam.a=-1.");
  ```

---

# Limitations

* Parameter classes can only include simple members! Currently, the following types are supported:
    * simple pods (e.g., `double x; char y;`)
    * std::string
    * fixed-size arrays of pods, serialized using the ROOT method:
       ```c++
       static constexpr int N=3; //!
       double array[N] = {1, 2, 3}; //[N] -- note the [N] after //!!
       ```
    * array parameters must be indexed textually:
      ```c++
      ConfigurableParam::fromString("ParamA.array[2]=10");
      ```
    * Support for pointers or objects is not currently available, and parameter classes cannot be nested.
* Serialization at present covers the entire parameter registry (all parameters together) and is written to a single file or snapshot.

# Wish list / planned improvements

---

The registry maintains a record of which source, such as CODE, CCDB, or RT, provided the current decisive value for each parameter. If a parameter remains unchanged, it retains the state from the previous stage.

# Changing Parameters via Command Line and Ini File

As previously discussed, parameters can be overridden from the command line using any DPL executable, like `o2-sim`, `o2-sim-digitizer-workflow`, or `o2-tpc-reco-workflow`, among others.

## Command Line Syntax
To modify a parameter from the command line, use the format `Key.param=value`. **NOTE:** There should be no spaces around the `=`. Multiple key-value pairs should be separated by a `;`:
```
o2-sim --configKeyValues 'A.p1=1;A.p2=2.56'
```
Not all parameters need to be specified; parameters that are not defined will use the default value set in the parameter struct.

---

# Example / HowTo:

Consider some algorithms, such as `algorithmA`, which rely on two parameters, `p1` and `p2`, and you wish to configure these parameters.

---

## Configuration File Format

The structure of the configuration file follows this pattern:
```EditorConfig
[Section1]
param1=value1
param2=value2
[Section2]
param1=value1
```

For example, a file named `paramA.ini`:
```EditorConfig
[A]
p1=1
```

This can be invoked via the command line:
```
o2-sim-digitizer-workflow --configFile paramA.ini
```
Note that not all parameters are required.

# Technical Specifications

* Parameter classes are immutable singleton classes/structs. By adhering to the pattern of inheriting from `ConfigurableParamHelper<T>` and utilizing the macro `O2ParamDef()`, the necessary implementations are handled automatically.
* The class layout is mapped to a text configuration using ROOT C++ introspection, requiring ROOT dictionaries for the parameter classes.
* BOOST property trees are employed for mapping to JSON/INI files, though this internal mechanism may evolve in the future.

# Constraints

Limitations:

---

You should follow these steps:
  1. Define a parameter class that includes the parameters and their default values.
     ```c++
     struct ParamA : ConfigurableParamHelper<ParamA> {
       int p1 = 10;
       double p2 = 1.23;
       // boilerplate code to make parameters known under key "A"
       O2ParamDef(ParamA, "A");
     };
     ```
  2. Include 
     ```c++
     O2ParamImpl(ParamA);
     ```
     in a source file to generate the necessary symbols for linking.
  3. Utilize the parameters in your code.
     ```c++
     void algorithmA() {
       // obtain the parameter singleton object
       auto& pa = ParamA::Instance();
       // use the parameters in your code
       doSomething(pa.p1, pa.p2);
     }
     ```