## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/MC/bin/o2_hybrid_gen.py

**Start chunk id:** 26e1a182eed931916f4d2f43b5153b051cd0fdf998fd7b4948ad04434ecb5bec

## Content

DOCUMENT:
    gens.append({
        'name': gen,
        'config': configs
    })
    add_trigger(gens[-1])
elif gen in noConfGen:
    gens.append({
        "name": gen,
        "config": ""
    })
    add_trigger(gens[-1])
else:
    print(f"The generator {gen} was not found in the list of available generators")
    exit(1)

---

# Initialize fractions list with 1 for each generator
fractions = [1] * len(gens)
    
# Insert generators and fractions into the data dictionary
data = {
    "mode": mode,
    "generators": gens,
    "fractions": fractions
}
    
# Save the data dictionary to a JSON file
with open(args.output, 'w') as f:
    json.dump(data, f, indent=2)

print(f"JSON file saved at {args.output}")

if __name__ == "__main__":
    main()

---

# This script generates a template JSON file for configuring the hybrid generator in O2sim.
# A list of generators to be utilized is provided through the --gen flag, and the output file name is specified with --output.
# All generators available in O2sim are supported. Alternatively, the --iniFile flag can be used to incorporate external generators
# configured via ini files. The --clone flag enables creating multiple instances of the generator list, which is beneficial for
# running multi-threaded event pools. This feature can be activated by setting the --mode flag to 'parallel', which is 'sequential' by default.
# The script leverages the ROOT dictionary to import parameter names; hence, O2 must be loaded to ensure the template generation works correctly.
# Example usage:
# $O2DPG_ROOT/MC/bin/o2_hybrid_gen.py --gen pythia8 boxgen external extkinO2 hepmc pythia8hf --clone 2 \

---

# Compile a list of elements in the gen flag
noConfGen = ["pythia8pp", "pythia8hf", "pythia8hi", "pythia8powheg"]
gens = []
if args.gen is None and args.iniFile is None:
    print("No generators specified")
    exit(1)
if args.gen:
    print(f"Generators to be used: {args.gen}")
    for gen in args.gen:
        if gen in gens_params:
            if gen == "hepmc":
                configs = [get_params(cmd_instance, cmd_params), get_params(gens_instances[gen], gens_params[gen])]
                gens.append({
                    'name': gen,
                    'config': {
                        "configcmd": configs[0],
                        "confighepmc": configs[1]
                    }
                })
                add_trigger(gens[-1])
            else:
                configs = get_params(gens_instances[gen], gens_params[gen])
                gens.append({

---

import argparse
import json
import ROOT
import cppyy
import numpy as np

# Retrieve the TClass object for the struct
tclass = ROOT.TClass.GetClass("o2::eventgen::Pythia8GenConfig")
tclass1 = ROOT.TClass.GetClass("o2::eventgen::BoxGenConfig")

generators_params = {"pythia8": "o2::eventgen::Pythia8GenConfig", "external": "o2::eventgen::ExternalGenConfig",
        "evtpool": "o2::eventgen::EventPoolGenConfig", "extkinO2": "o2::eventgen::O2KineGenConfig",
        "hepmc": "o2::eventgen::HepMCGenConfig", "boxgen": "o2::eventgen::BoxGenConfig"}
cmd_params = "o2::eventgen::FileOrCmdGenConfig"
generators_instances = {"pythia8": ROOT.o2.eventgen.Pythia8GenConfig(), "external": ROOT.o2.eventgen.ExternalGenConfig(),
        "evtpool": ROOT.o2.eventgen.EventPoolGenConfig(), "extkinO2": ROOT.o2.eventgen.O2KineGenConfig(),
        "hepmc": ROOT.o2.eventgen.HepMCGenConfig(), "boxgen": ROOT.o2.eventgen.BoxGenConfig()}
cmd_instance = ROOT.o2.eventgen.FileOrCmdGenConfig()

---

def main():
    parser = argparse.ArgumentParser(description='Generate a JSON file using command line arguments.')
    parser.add_argument('--gen', type=str, nargs='+', help='List of generators to be utilized')
    parser.add_argument('--iniFile', type=str, nargs='+', help='List of external generators configured with ini files')
    parser.add_argument('--mode', type=str, help='Run generators in sequential or parallel mode for faster event generation (multi-threading)')
    parser.add_argument('--output', type=str, required=True, help='Path for the output JSON file')
    parser.add_argument('--clone', type=int, help='Number of generator list clones to create')
    parser.add_argument('--trigger', action='store_true', help='Include triggers in the template JSON file')

    args = parser.parse_args()

---

DOCUMENT:
    args = parser.parse_args()

    # Validate the mode
    valid_modes = ["sequential", "parallel"]
    mode = args.mode if args.mode in valid_modes else "sequential"
    if args.mode and args.mode not in valid_modes:
        print(f"The mode {args.mode} is invalid. Please choose between 'sequential' or 'parallel'")
        print("Sequential mode will be used by default")
    else:
        print(f"Running in {mode} mode")

    # The trigger options are limited to "off", "or", "and". Any other option will result in "off"

    add_trigger = lambda d: d.update({"triggers": {"mode": "off", "specs": [{"macro": "", "function": ""}]}}) if args.trigger else None

---

if args.iniFile:
    print(f"External generators to be used: {args.iniFile}")
    for file in args.iniFile:
        if ".ini" != file[-4:]:
            print(f"File {file} is not an ini file")
            exit(1)
        configs = get_params(gens_instances["external"],gens_params["external"])
        configs["iniFile"] = file
        gens.append({
            'name': 'external',
            'config': configs
        })
        add_trigger(gens[-1])

if args.clone:
    if args.clone < 2:
        print("The cloning value must be greater than 1")
        print("Skipping procedure...")
    else:
        print(f"Cloning the generator list {args.clone} times")
        gens = gens * args.clone

---

def get_params(instance, class_name):
    tclass = ROOT.TClass.GetClass(class_name)
    members = tclass.GetListOfDataMembers()
    params = {}
    for member in members:
        if isinstance(member, ROOT.TDataMember):
            member_value = getattr(instance, member.GetName())
            params[member.GetName()] = member_value
    # replace C++ strings and arrays
    for key, value in params.items():
        if isinstance(value, cppyy.gbl.std.string):
            # convert to a JSON serializable Python string
            params[key] = str(value)
        elif hasattr(value, '__len__') and hasattr(value, '__getitem__'):
            # convert C++ numerical array to Python array, no string arrays are declared as parameters, so far
            params[key] = np.array(value).tolist()
    return params

---

#!/usr/bin/env python3

# This script is written in Python 3.

---

#                                     --output config.json --mode parallel --iniFile /path/to/file0.ini /path/to/file1.ini