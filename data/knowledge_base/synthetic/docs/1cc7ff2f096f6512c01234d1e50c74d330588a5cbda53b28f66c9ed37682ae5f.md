## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/MC/prodinfo/mcprodinfo_ccdb_upload.py

**Start chunk id:** 1cc7ff2f096f6512c01234d1e50c74d330588a5cbda53b28f66c9ed37682ae5f

## Content

DOCUMENT:
    def query_mcprodinfo(base_url, user, run_number, lpm_prod_tag, cert_dir="/tmp"):
    """
    Fetches MCProdInfo from CCDB. Returns an object or None.
    """
    # Verify the existence of tokenfiles
    key_path = os.environ.get("JALIEN_TOKEN_KEY")
    cert_path = os.environ.get("JALIEN_TOKEN_CERT")
    if key_path is None and cert_path is None:
       uid = os.getuid()
       cert_path = os.path.join(cert_dir, f"tokencert_{uid}.pem")
       key_path = os.path.join(cert_dir, f"tokenkey_{uid}.pem")

    # Construct the full URL
    user_path = 'Users/' + user[0] + '/' + user
    start = run_number
    stop = run_number + 1 
    url = f"{base_url}/browse/{user_path}/MCProdInfo/{lpm_prod_tag}/{start}/{stop}"

---

# Create unique certificate and key file paths based on user ID
key_path = os.environ.get("JALIEN_TOKEN_KEY")
cert_path = os.environ.get("JALIEN_TOKEN_CERT")
if key_path is None and cert_path is None:
    uid = os.getuid()
    cert_path = os.path.join(cert_dir, f"tokencert_{uid}.pem")
    key_path = os.path.join(cert_dir, f"tokenkey_{uid}.pem")

# Construct full URL
query = "/".join([f"{k}={v}" for k, v in keys.items()])
user_path = 'Users/' + user[0] + '/' + user
start = run_number
stop = run_number + 1 
url = f"{base_url}/{user_path}/MCProdInfo/{lpm_prod_tag}/{start}/{stop}/{query}"

print(f"Complete URL: {url}")

# Set up request
with open(empty_file, 'rb') as f:
    files = {'blob': f}
    response = requests.post(url, files=files, cert=(cert_path, key_path), verify=False)

# Optional: delete temporary file
os.remove(empty_file)

return response

---

PARAMETERS:
- base_url (str): The base HTTPS URL, e.g., "https://URL"
- user (str): The uploader, which determines the location "Users/f/foo_bar/MCProdInfo/..."
- keys (dict): A dictionary containing meta information to upload, such as {"key1": "var1", "key2": "var2"}
- cert_dir (str): The directory where the .pem files are stored (default: /tmp)

RETURNS:
- A response object from the POST request
"""
# Create an empty file
empty_file = "empty.dat"
with open(empty_file, "w") as f:
    f.write("0")

---

def extract_metadata_blocks_from_CCDB(text: str):
    blocks = []
    # Split the text on 'Metadata:\n' and process each block
    sections = text.split('Metadata:\n')
    for section in sections[1:]:  # skip the initial section before any Metadata:
        metadata = {}
        for line in section.splitlines():
            if not line.strip():  # stop processing at the first blank line
                break
            match = re.match(r'\s*(\w+)\s*=\s*(.+)', line)
            if match:
                key, val = match.groups()
                # Convert the value types
                if val == "None":
                    val = None
                elif val.isdigit() or (val.startswith('-') and val[1:].isdigit()):
                    val = int(val)
                else:
                    try:
                        val = float(val)
                    except ValueError:
                        val = val.strip()
                metadata[key] = val
        if metadata:
            blocks.append(metadata)

---

DOCUMENT:
    response = requests.get(url, cert=(cert_path, key_path), verify=False)
    if response.status_code != 404:
        meta = extract_metadata_blocks_from_CCDB(response.content.decode('utf-8'))
        if len(meta) > 0:
          def filter_known_fields(cls, data: dict) -> dict:
            valid_keys = {f.name for f in fields(cls)}
            return {k: v for k, v in data.items() if k in valid_keys}
        
          clean_meta = filter_known_fields(MCProdInfo, meta[0])
          return MCProdInfo(**clean_meta)
       
    return None


def upload_mcprodinfo_meta(base_url, user, run_number, lpm_prod_tag, keys, cert_dir="/tmp"):
    """
    Uploads an empty .dat file using client certificates.
    """

---

DOCUMENT:
    metadata[key] = val
    if metadata:
        blocks.append(metadata)
    return blocks

---

def __post_init__(self):
    if self.Hash is None:
        # Only hash meaningful fields
        data_to_hash = {
            k: v for k, v in asdict(self).items()
            if k != 'Hash'
        }
        hash_str = hashlib.sha256(
            json.dumps(data_to_hash, sort_keys=True).encode()
        ).hexdigest()
        object.__setattr__(self, 'Hash', hash_str)


import re

---

import json
import os
import requests
import subprocess

import dataclasses # to define the MCProdInfo data layout and convert it to a dictionary
from dataclasses import dataclass, field, asdict, fields
from typing import Optional
import hashlib

@dataclass(frozen=True)
class MCProdInfo:
    """
    structure for MonteCarlo production information
    """
    LPMProductionTag: str
    Col: int
    IntRate: float   # indicative of an interaction rate, which may vary during the run
    RunNumber: int
    OrbitsPerTF: int
    # max_events_per_tf: Optional[int] = -1
    Comment: Optional[str] = None
    Hash: Optional[str] = field(default=None)