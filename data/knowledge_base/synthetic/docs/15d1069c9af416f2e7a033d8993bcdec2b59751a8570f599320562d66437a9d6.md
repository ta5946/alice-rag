## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/UTILS/cmpROOTFiles.py

**Start chunk id:** 15d1069c9af416f2e7a033d8993bcdec2b59751a8570f599320562d66437a9d6

## Content

elif isTree1 and isTree2:
    success = success and compare_trees(obj1, obj2)

# Close the files
tfile1.Close()
tfile2.Close()

return success

result = compare_root_files(args.file1, args.file2)
if result:
    print("The byte content of the two ROOT files matches.", args.file1, args.file2)
else:
    print("The byte content of the two ROOT files does not match.", args.file1, args.file2)

---

#!/usr/bin/env python3
import ROOT
import argparse

parser = argparse.ArgumentParser(description='Verify if two ROOT files are binary compatible',
                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter)

parser.add_argument('-f1','--file1', help='First ROOT TFile', required=True)
parser.add_argument('-f2','--file2', help='Second ROOT TFile', required=True)
args = parser.parse_args()

def extract_total_branch_list(tree):
    branches = []

    # Function to recursively extract branches
    def extract_branches_recursive(branch):
        branches.append(branch)
        sub_branches = branch.GetListOfBranches()

        if sub_branches:
            for sub_branch in sub_branches:
                extract_branches_recursive(sub_branch)

    # Get top-level branches of the tree
    top_level_branches = tree.GetListOfBranches()

    # Traverse recursively through branches
    for branch in top_level_branches:
        extract_branches_recursive(branch)

    return branches

---

DOCUMENT:
    return branches


def compare_branches(obj1, obj2):
    # Verify that the object classes are identical
    if obj1.IsA() != obj2.IsA():
      print("Object types do not match")
      return False

    # Ensure the titles are the same
    if obj1.GetTitle() != obj2.GetTitle():
      print("Titles do not match")
      return False

    # Convert objects to TBuffer to compare their byte content
    #buffer1 = ROOT.TBuffer(ROOT.TBuffer.EMode.kWrite, 10000)
    #buffer2 = ROOT.TBuffer(ROOT.TBuffer.EMode.kWrite, 10000)

    #obj1.Streamer(buffer1)
    #obj2.Streamer(buffer2)
    # check the branch
    print("Checking branch " + obj1.GetTitle())
    if obj1.GetTotBytes() != obj2.GetTotBytes():
      print("Byte counts differ")
      return False


# compare two TTree objects
def compare_trees(tree1, tree2):
    branches1 = get_total_branch_list(tree1)
    branches2 = get_total_branch_list(tree2)

---

DOCUMENT:
    inters = set1.intersection(set2)
    #print (inters)
    symdiff = (set1.symmetric_difference(set2))
    if (len(symdiff) > 0):
      print (symdiff)
    return len(symdiff) == 0

def compare_root_files(file1, file2):
    # Open the ROOT files
    tfile1 = ROOT.TFile.Open(file1)
    tfile2 = ROOT.TFile.Open(file2)

    # Retrieve the list of keys (TKeys) from the ROOT files
    keys1 = tfile1.GetListOfKeys()
    keys2 = tfile2.GetListOfKeys()

    # Verify if the number of keys is identical
    if keys1.GetEntries() != keys2.GetEntries():
        return False

    # Iterate through the keys and compare their byte content
    success = True
    for key1, key2 in zip(keys1, keys2):
        obj1 = key1.ReadObj()
        obj2 = key2.ReadObj()
        
        isTree1 = isinstance(obj1, ROOT.TTree)
        isTree2 = isinstance(obj2, ROOT.TTree)
        if isTree1 != isTree2:
            success = False

---

# The number of branches must match
if len(branches1) != len(branches2):
  return False

# Branch order is not important, so we create two hash sets containing tuples of (branchname, totalsize)

set1 = set()
for br in branches1:
  # Print key name and class name
  #print("Key: ", br.GetName())
  #print("Class: ", br.ClassName())
  #print("BC: ", str(br.GetTotalSize()))
  #print("---------------")
  
  totals = 0
  for entry in range(br.GetEntries()):
    totals += br.GetEntry(entry)
  set1.add((br.GetName(), totals, br.GetEntries()))

set2 = set()
for br in branches2:
  totals = 0
  for entry in range(br.GetEntries()):
    totals += br.GetEntry(entry)
  set2.add((br.GetName(), totals, br.GetEntries()))