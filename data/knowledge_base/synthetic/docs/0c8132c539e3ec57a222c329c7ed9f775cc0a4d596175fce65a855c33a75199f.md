## Metadata

**Document link:** https://github.com/AliceO2Group/simulation/blob/main/additional_resources/talks/O2_AnalysisTutorial_April2023/ALICE-Run3-MC-HowTo.pdf

**Start chunk id:** 0c8132c539e3ec57a222c329c7ed9f775cc0a4d596175fce65a855c33a75199f

## Content

‚Ä¢ Furthermore, detailed event-level metadata for each generated event is found in a distinct file (o2sim_MCHeader.root).


‚Ä¢

For example, the impact parameter in PbPb collisions.

‚Äúa histogram showing the production vertex-y of all MC tracks (both primary and secondary)‚Äù


11
Key helper classes for accessing Monte Carlo (MC) kinematics

üëâ Example: Run/SimExamples/
Jet_Embedding_Pythia8

‚Ä¢ Manually reading and navigating through kinematics data can be tedious (ROOT-IO boilerplate).


‚Ä¢ Provide two main utility classes to simplify this process for users.


‚Ä¢ MCKinematicsReader - A class designed to easily read and retrieve tracks for a specific event or Monte Carlo label.


‚Ä¢ MCTrackNavigator - A class for navigating through the mother-daughter tree of MC tracks and querying physics properties.

‚ÄúLoad all MC tracks from the stored kinematics file for event id 1, then loop through each track to identify the direct mother particle and the primary ancestor in every case‚Äù

---

"Create 10 default Pythia8 pp events and pass them through the entire ALICE detector.

Create 10 default Pythia8 pp events and route them via 8 Geant3 workers through the ALICE detector except for ZDC, applying a L3-field of 2kGauss.

Simply generate 10 default Pythia8 pp events without further processing.

(o2-sim basic usage in examples)

‚Ä¢ Some examples of o2-sim usage:

o2-sim -n 10 -g pythia8pp

o2-sim -n 10 -g pythia8pp -j 8     
‚Äî-skipModules ZDC ‚Äî-field 2 -e 
TGeant3

 o2-sim -n 10 -g pythia8pp \          
        ‚Äî-noGeant

"Create 10 default Pythia8 pp events and pass them through the entire ALICE detector.

Create 10 default Pythia8 pp events and route them via 8 Geant3 workers through the ALICE detector except for ZDC, applying a L3-field of 2kGauss.

Simply generate 10 default Pythia8 pp events without further processing.

(o2-sim basic usage in examples)

‚Ä¢ o2-sim --help lists main options and shows defaults"

---

12

using o2::steer; using o2; // access kinematics file with simulation prefix o2sim MCKinematicsReader reader("o2sim", MCKinematicsReader::Mode::kMCKine); // retrieve all Monte Carlo tracks for the current event std::vector<MCTrack> const& tracks = reader.getTracks(event); for (auto& t : tracks) {    // process tracks; locate the mother track of each track (among all tracks)    auto mother = o2::mcutil::MCTrackNavigator::getMother(t, tracks);    if (mother) {       std::cout << "This track has a mother\n";    }    // find the (backward first) primary particle from which this track originates    auto primary = o2::mcutil::MCTrackNavigator::getFirstPrimary(t, tracks); }
Generators: Basic

‚Ä¢ o2-sim provides a few predefined generators (choose with the -g option)


‚Ä¢ phythia8pp       (pre-configured Pythia8 for pp)


‚Ä¢ phythia8hi        (pre-configured Pythia8 for PbPb)


‚Ä¢ boxgen             (a simple mono-PDG generator)

---

DOCUMENT:
    alienv enter O2sim/latest

nightly precompiled builds (CentOS)

/cvmfs/alice.cern.ch/bin/alienv enter O2sim::v20230419-1

4
A reminder of the traditional workflow in high-energy physics and the importance of simulation

Real particle collisions

~TB/s

sensor data

Reconstruction

Takes sensor data and reconstructs the particle states immediately following collisions

PetaBytes

AOD data
(Structured) high-level physics data for querying and analysis

Physics Analysis

Data analysis to identify physics results and generate papers

A reminder of the traditional workflow in high-energy physics and the importance of simulation

Real particle collisions

~TB/s

sensor data

Reconstruction

Takes sensor data and reconstructs the particle states immediately following collisions

PetaBytes

AOD data
(Structured) high-level physics data for querying and analysis

Physics Analysis

Data analysis to identify physics results and generate papers

We are simulating for

‚Ä¢ detector and system design

---

OF VARIOUS COMPONENTS


‚Ä¢ Core simulation part:


‚Ä¢ Event generation


‚Ä¢ Transport simulation


‚Ä¢ Digitization


‚Ä¢ Moreover, MC workflows may engage all


‚Ä¢ Reconstruction, QC, Analysis, etc.


Event generation and transport/simulation

Digitization of detectors

Code for detector and global reconstruction

AOD creation

QC

Analysis

...

PWG configurations

Integration of all components into coherent workflows, accomplished through:


‚Ä¢ Individual parts stored in O2 and O2Physics repositories

‚Ä¢ O2DPG repository (primarily for physics studies on GRID)

‚Ä¢ full_system_test (mainly for data-taking simulations)

6
Data products within the simulation pipeline

Event generation and transport simulation

Digitization

Reconstruction

Physics analysis

‚Ä¢ Geometry file

‚Ä¢ Kinematics file

‚Ä¢ Detector response files (hits)

‚Ä¢ Digits == detector sub-timeframes

‚Ä¢ Similar to or close to raw detector output

‚Ä¢ Global reconstructed tracks

‚Ä¢ Primary and secondary vertexes


‚Ä¢ etc.

---

‚Ä¢ Step Two: Execute the MC job with a dynamic graph scheduler.

WorkÔ¨Çow creator

WorkÔ¨Çow executor

Output (AOD) 

Generates a well-organized, integrated MC 
workÔ¨Çow in directed-acyclic-graph (DAG) form, 
represented as a JSON, which models the 
dependencies between tasks.


Configures the MC workÔ¨Çow based on key 
user parameters

‚Ä¢ Collision system, generators, interaction rate, 
number of timeframes

workÔ¨Çow.json

Manages the execution of the DAG workÔ¨Çow on 
multi-core systems akin to a dynamic 
"build" tool


Initiates tasks as soon as they are ready:

‚Ä¢ Optimizing for high parallelism and CPU 

utilization


‚Ä¢ Ensures adherence to resource limitations (avoids system overloading)


In essence, a versatile tool, not limited to MC

‚òù Good to know: 

‚Ä¢ DAG workÔ¨Çow resembles a DPL topology


‚Ä¢ However, the DAG workÔ¨Çow runs in stages with intermediate 
files stored on disk


‚Ä¢ A DPL topology would not Ô¨Åt into GRID memory

20
MC workflow creation: Essential basic features

üëâ Examples provided here;  üëâ Documentation available here

---

‚Ä¢ When Pythia8 is employed, it can be thoroughly configured through a dedicated text file and the GeneratorPythia8 parameter.


‚Ä¢ Detailed valid settings are available in the Pythia8 reference manual.


‚Ä¢ Additionally, we offer a tool named mkpy8cfg.py to assist in the configuration file creation process.


üëâ Example: Run/SimExamples/
Jet_Embedding_Pythia8

pythia8.cfg

### random  
Random:setSeed = on  
Random:seed = 130145275  

### beams  
Beams:idA = 1000822080  
Beams:idB = 1000822080  
Beams:eCM = 5020.000000  

### processes  

### heavy-ion settings (valid for Pb-Pb 5520 only)  
HeavyIon:SigFitNGen = 0  
HeavyIon:SigFitDefPar = 13.88,1.84,0.22,0.0,0.0,0.0,0.0,0.0  
HeavyIon:bWidth = 14.48  

### decays  
ParticleDecays:limitTau0 = on  
ParticleDecays:tau0Max = 10.  

### phase space cuts  
PhaseSpace:pTHatMin = 0.000000  
PhaseSpace:pTHatMax = -1.000000 

run with this config

o2-sim -n 10 -g pythia8 ‚Äî-configKeyValues 
‚ÄúGeneratorPythia8.config=pythia8.cfg‚Äù

---

‚Ä¢ The ALICE detector is integrated into well-known particle-transport engines that incorporate actual physics models and particle transport mechanisms.

‚Ä¢ Geant4, Geant3, and FLUKA can be utilized interchangeably via the Virtual Monte Carlo API.

‚Ä¢ The primary functions of o2-sim include:

‚Ä¢ Creation of ALICE detector geometry


‚Ä¢ Event generation (primary particle creation)


‚Ä¢ Simulation of particle interactions with detector material (secondary particle production, etc.) and particle transport until they exit the detector or stop


‚Ä¢ Formation of hits (energy depositions) as a preliminary step for detector response following particle passage

‚Ä¢ In Run3, o2-sim introduces scalable, multi-core simulation with sub-event parallelism, enabling rapid results for large events on powerful servers


‚Ä¢ Notably, o2-sim processes events in complete isolation‚Äîno timeframe concept is applied during simulation (only during digitization)

8
Examples of o2-sim usage

‚Ä¢ Several examples demonstrating how to use o2-sim ...

o2-sim -n 10 -g pythia8pp

---

MC workflow creation: Useful basic features

üëâ Examples available here;  üëâ More details here

WorkÔ¨Çow creator

WorkÔ¨Çow executor

Output 
(AOD) 

O2DPG/MC/bin/o2dpg_sim_workflow.py

‚Ä¢ ALICE Run3 MC workÔ¨Çow creation handled by the script O2DPG/MC/bin/o2dpg_sim_workflow.py 

‚Ä¢ Configures the MC workÔ¨Çow based on key (user) parameters (Collision system, generators, interaction rate, number of 

timeframes, transport engine, etc.)


‚Ä¢ As expected, o2dpg_sim_workflow.py ‚Äî-help provides a list of available options

---

‚Ä¢ boxgen             (a straightforward single-PDG generator)


‚Ä¢ extkinO2           (utilize an external kinematics file, e.g., created in a previous step)


‚Ä¢ hepmc              (import events from a HepMC file)

o2-sim -g [ pythia8pp | pythia8hi | boxgen | extkinO2 | hepmc ] ‚Ä¶

13
Generators: Basic

‚Ä¢ o2-sim includes several pre-configured generators (choose one using the -g option)


‚Ä¢ pythia8pp       (a pre-set Pythia8 configuration for pp interactions)


‚Ä¢ pythia8hi        (a pre-set Pythia8 configuration for PbPb interactions)


‚Ä¢ boxgen             (a simple single-PDG generator)


‚Ä¢ extkinO2           (use an external kinematics file, e.g., generated in a pre-step)


üëâ Example: run/SimExamples/JustPrimaryKinematics

‚Ä¢ hepmc              (import events from a HepMC file)

üëâ Example: run/SimExamples/HepMC_STARlight

o2-sim -g [ pythia8pp | pythia8hi | boxgen | extkinO2 | hepmc ] ‚Ä¶

13
Generators: Pythia8

‚Ä¢ Pythia8 is more tightly integrated into O2 

(compared to other generators) and is recommended 

for use whenever possible


‚Ä¢ When Pythia8 is employed, it allows for full

---

‚Ä¢ examples demonstrating the use of o2-sim ‚Ä¶

o2-sim -n 10 -g pythia8pp

‚ÄúCreate 10 standard Pythia8 
pp events and propagate them 
through the entire ALICE 
detector‚Äù

9
Basic examples for o2-sim usage

‚Ä¢ examples demonstrating the use of o2-sim ‚Ä¶

o2-sim -n 10 -g pythia8pp

o2-sim -n 10 -g pythia8pp -j 8     
‚Äî-skipModules ZDC ‚Äî-field 2 -e 
TGeant3

‚ÄúGenerate 10 standard Pythia8 
pp events and propagate them 
through the whole ALICE 
detector‚Äù

‚ÄúProduce 10 standard Pythia8 pp events 
and propagate them with 8 Geant3 
workers, excluding ZDC, and apply a magnetic field 
of 2kGauss‚Äù

9
Basic examples for o2-sim usage

‚Ä¢ examples demonstrating the use of o2-sim ‚Ä¶

o2-sim -n 10 -g pythia8pp

o2-sim -n 10 -g pythia8pp -j 8     
‚Äî-skipModules ZDC ‚Äî-field 2 -e 
TGeant3

 o2-sim -n 10 -g pythia8pp \          
        ‚Äî-noGeant

‚ÄúCreate 10 standard Pythia8 
pp events and propagate them 
through the entire ALICE 
detector‚Äù

---

üëâ Example: Run/SimExamples/
Selective_Transport_pi0

‚Äúrun o2-sim with the pythia8pp generator, passing only events that meet the trigger criteria defined in the file Trigger.C‚Äù

o2-sim -n 10 -g pythia8pp -t external --
configKeyValues 
‚ÄòTriggerExternal.fileName=myTrigger.C;TriggerExternal.funcName=‚Äútrigger‚Äù'

‚Äúcontent of the ROOT macro file myTrigger.C‚Äù

// provides a fully customizable event trigger function 
o2::eventgen::Trigger trigger() 
{ 
  return [](const std::vector<TParticle>& particles) 
-> bool { 
    return true; // triggered 
  } 
}

16
o2-sim as an On-the-Fly Event Generator for Analysis

üëâ Example: Run/SimExamples/
MCTrackToDPL

‚Ä¢ o2-sim can serve as a generator within the DPL (analysis) framework, directly injecting events without storing them in between.

‚Ä¢ beneficial for rapid simulation studies within the analysis setup or for primary-only analysis tasks.

‚Ä¢ will be featured in the tutorial for PWG-EM

A Large Ion Collider Experiment

---

‚Ä¢ Typically, o2dpg_sim_workflow.py --help displays available options.

${O2DPG_ROOT}/MC/bin/o2dpg_sim_workflow.py -eCM 14000 -col pp -gen pythia8 -proc cdiff -tf 5 -ns 2000

"Generate an ALICE-Run3 Monte Carlo workflow for a 5 timeframe simulation, with 2000 events per timeframe, at an interaction rate of 500kHz ‚Ä¶ for 14TeV pp collisions using Pythia8 with the special process cdiÔ¨Ä enabled."

 -interactionRate 500000 -run 302000

Key options include: -gen, -tf, -n, -eCM, -interactionRate, -run, -col

Additional options are: -field, -seed, -proc

21
Workflow creation: Run numbers

‚Ä¢ Utilizing a run number is essential as it is required for determining the timestamp to retrieve conditions from CCDB.

‚Ä¢ Therefore, run numbers should be employed even for non-data-taking simulations.

---

‚Ä¢ The core function of digitization is to


‚Ä¢ transform straightforward energy deposits into detector signals (digits) that ultimately

mirror the raw detector output


‚Ä¢ place individual generated events within a timeline collection


‚Ä¢ address pileup effects and triggering


‚Ä¢ Digitization serves as a signal embedding/mixing mechanism


‚Ä¢ Digitization can function as an event-mixing/event-embedding framework


‚Ä¢ signal-background embedding enables the injection of signal events into a repeated 
set of background events (saves transport simulation time)


‚Ä¢ can design sequences of event types within a timeframe (a signal event 

following every n-th min-bias event)

üëâ Embedding example in O2DPG: 
PWGHF embedding

27

---

"Run the workflow up to the AOD task (assuming an 8-core CPU setup).

‚Ä¢ Checkpointing and incremental build

‚Ä¢ Transform the DAG into a basic shell script that can be executed independently

o2dpg_workflow_runner.py -f workflow.json -tt digi
o2dpg_workflow_runner.py -f workflow.json -tt aod

"First, run the workflow until digitization, then proceed to AOD, without repeating completed tasks!

o2dpg_workflow_runner.py -f workflow.json -tt aod
‚Äî-generate-script my_script.sh

"Create a simple shell script that handles the workflow up to the AOD stage"

23
MC workflow execution: basic features

O2DPG/MC/bin/o2dpg_workflow_runner.py

WorkÔ¨Çow creator

WorkÔ¨Çow executor

Output 
(AOD) 

‚Ä¢ The workflow runner/executor assesses and builds a DAG workÔ¨Çow on a compute node

‚Ä¢ At minimum, it requires a workflow file and a target

${O2DPG_ROOT}/MC/bin/o2dpg_workflow_runner.py -f workflow.json -tt aod

"Run the workflow up to the AOD task 
(assuming 8-core CPU conÔ¨Åg)"

---

‚Ä¢ Global reconstructed tracks

‚Ä¢ Primary and secondary vertexes


‚Ä¢ etc.

‚Ä¢ AOD (analysis object data)


o2-sim: The ALICE Run3 transport simulator
‚Ä¢ o2-sim serves as the particle-detector simulator for ALICE Run3


‚Ä¢ It integrates ALICE detector simulations with established particle-transport engines that include physics models and particle tracking


‚Ä¢ It supports Geant4, Geant3, and FLUKA through the Virtual Monte Carlo API


‚Ä¢ Key responsibilities of o2-sim include:

‚Ä¢ Creation of ALICE detector geometry


‚Ä¢ Event generation (primary particle creation)


‚Ä¢ Simulation of particle interactions with detector material (secondary particle creation, etc.), and tracking particles until they exit the detector or come to a stop


‚Ä¢ Generation of hits (energy deposits) as a precursor to detector response following particle passage

---

(pure generator output)

‚Ä¢ o2-sim --help provides an overview of primary options and displays default settings.

9
o2-sim: Monitoring the Simulation Process

‚Ä¢ o2-sim generates three internal log files (one from each micro-service), which are useful for observing the simulation process or troubleshooting.

o2sim_serverlog
o2sim_workerlog0
(o2sim_mergerlog)

10
o2-sim: Kinematics Data Output

‚Ä¢ The default kinematics output file, o2sim_Kine.root, from the transport simulation is the most pertinent for physics analysis.

‚Ä¢ It includes information on the creation vertices, momenta, and other details of primary (generated) and secondary (transported) particles created during the simulation.

‚Ä¢ It also contains information on the physics creation process, including particle origins and lineage.

‚Ä¢ Based on the o2::MCTrack class, which is essentially a simplified version of TParticle.

‚Ä¢ For each event, there is one entry of vector<MCTracks> in a TTree.

‚Ä¢ By default, kinematics data is pruned to retain only relevant particles.

‚Ä¢ Additionally, it provides event-level metadata for each event.

---

‚Ä¢ Step Two: Execute the MC job using a dynamic graph scheduler

Workflow constructor

Workflow executor

Output (AOD) 

Generates a coherent, integrated MC 
workflow in directed-acyclic-graph 
(DAG) form, represented as a JSON, 
illustrating the interdependencies between tasks


Adapts the MC workflow based on key user 
parameters

‚Ä¢ Collision system, generators, interaction rate, number of 
timeframes

workflow.json

Manages the execution of the DAG workflow on multi-core systems similar to a dynamic 
‚Äúbuild‚Äù tool


Schedules tasks as they become executable:

‚Ä¢ Aimed at achieving high parallelism and CPU 

utilization


‚Ä¢ Ensures adherence to resource limitations (avoids system overload)


In theory, a versatile tool, applicable beyond MC

20
Fundamentals of O2DPG-MC

‚Ä¢ Running an MC job involves a two-step process to separate configuration logic from execution logic


‚Ä¢ Step One: Develop a valid/configured description of an MC job referred to as a ‚Äúworkflow‚Äù


‚Ä¢ Step Two: Execute the MC job using a dynamic graph scheduler

Workflow constructor

---

‚Ä¢ Link to PWGDQ cocktail generator 

‚Äústub content of ROOT macro file myGen.C‚Äù

// my fully custom generator 
class MyCustomGen : o2::generator::GeneratorTGenerator { 
  void Init() override; 
  bool generateEvent() override; 
}; 

FairGenerator* createGenerator(double energy) { 
  return new MyCustomGen(energy); 
}

15
Event Filtering and Triggering

‚Ä¢ Event filtering or triggering can also be flexibly managed at the generator level

‚Ä¢ For instance, events with specific properties can be selectively generated and simulated

‚Ä¢ Users can implement a configurable "external" trigger using the "external" generator framework

‚Ä¢ This involves creating a trigger function in a separate ROOT macro and passing it to o2-sim with the `-t external` option

‚Ä¢ The trigger function evaluates the vector of all generated particles

‚Ä¢ Advanced: DeepTriggers enable triggering based on the collection of primary particles and additional internal details from the generator

üëâ Example: Run/SimExamples/
Selective_Transport_pi0

---

USER TASK

Normal path:
Full simulation

DPL

User task

New path:
Upgrade 
simulation 

on disk

Standard O2 derived data
(for small tests)
@D. Chinellato 

Improve data models for enhanced service integration!

Supply code/systems as part of 

the official global MC processing 

environment for reproducibility!

10

17
Integrated workflows: O2DPG MC

To generate simulated AODs, it is necessary to extend 

the usage of o2-sim and event generation to encompass the entire 

algorithmic pipeline, including digitization and reconstruction 

steps.


This is a sophisticated system comprising numerous executables or 
tasks, necessitating consistent application and propagation of 
settings/configurations to function harmoniously.


For instance, a full-system-test for data-taking.


It's challenging to get right on your own ‚Äî> leverage a maintained setup!


For ALICE Run3, the official production system aimed at 

GRID productions is the O2DPG repository (MC component).


O2DPG also includes scripts and setup for data-taking (DATA component).

---

default resources on the GRID


‚Ä¢ You should also meet these requirements when running locally on your laptop


‚Ä¢ These requirements manifest as default settings that are included in the workflow creation/execution


‚Ä¢ Transport simulation will utilize 8 workers


‚Ä¢ TPC and TRD digitization will use 8 threads


‚Ä¢ The workflow runner assumes access to 8 cores


‚Ä¢ However, O2DPG MC workloads could present issues on hardware with fewer resources


‚Ä¢ With some tuning, though, it may still be feasible to run them

24
Beyond this: Additional keywords

‚Ä¢ There are many more advanced 

topics that will be covered


‚Ä¢ ‚Ä¶ this basic set of slides does not cover everything‚Ä¶


‚Ä¢ Get in touch for more 

details !


‚Ä¢ Help us enhance the 

documentation, which is still in its early stages !

‚Ä¶ and much more

25
Backup
Digitization, embedding (signal mixing)

‚Ä¢ Digitization is less critical for physics analysis‚Ä¶


‚Ä¢ The core task of digitization is to

---

We are simulating for

‚Ä¢ detector and systems design

‚Ä¢ calibrating reconstruction algorithms

‚Ä¢ understanding reconstruction algorithm efficiency

‚Ä¢ practicing data-taking system with synthetic data

‚Ä¢ assessing background effects

‚Ä¢ radiation studies

‚Ä¢ etc.

Virtual particle collisions 
+ (detector) simulation 
based on physics models
Insight into the ALICE Run3 simulation framework

‚Ä¢ The framework includes multiple elements


‚Ä¢ The core simulation section includes


‚Ä¢ Event generation


‚Ä¢ Transport simulation


‚Ä¢ Digitization


‚Ä¢ Additionally, MC workflows can test


‚Ä¢ Reconstruction, Quality Control, Analysis, and more


‚Ä¢ Individual components are managed in O2 and O2Physics repositories

Event generators
Transport/Detector 
simulation

Detector digitisation

Detector and global 
reconstruction code 

AOD creation

QC

Analysis

‚Ä¶

6

---

tasks


‚Ä¢ will be included in the tutorial for PWG-EM

A Large Ion Collider Experiment

Primary goal: Integration and reproducibility of ALICE3 
pipelines, encompassing full and fast-simulation tools

o2-sim 
processes

VMC 
worker
transport
worker

writer

generator

asynchronous reconstruction

MC information

stored on disk

Digitization and reconstruction

AO2D producer

DPL

MC collisions, MC tracks
(without transport)

Proxy

DPL

MC information

kept in memory

On-the-fly 
detector

‚Ä¢

‚Ä¢

‚Ä¢

Full simulation alongside‚Ä¶
Cellular automaton tracker
ACTS

‚Ä¢ Detector parameterization

‚Ä¢

Something we overlooked‚Ä¶

Simulation parameters

lookup 
table

Delphes track 
smearing

PID performance 
parameters

Any 

configuration

Particle identification 
parametrization

Any converter from 

MC generated to 

reconstruction

Versatile and flexible!

ALICE3 CERN Evian Workshop | January 31, 2023 |  M. Concas, S. Wenzel

Reconstruction

MC information

on disk

Reconstruction

MC information

in memory

User task

Standard route:
Full simulation

DPL

User task

Alternative route:
Enhanced 
simulation 

on disk

---

‚Ä¢ O2DPG includes scripts and setup for data-taking operations (DATA part).

The interaction among algorithms forms a complex system (DPL topology).

O2DPG:

‚Ä¢ offers a definitive setup for official MC productions for ALICE-Run3 and provides a runtime environment for executing MC jobs on the GRID.

‚Ä¢ ensures all necessary processing tasks are integrated into a cohesive and consistent framework, enabling a seamless pipeline from event generation through AOD and beyond.

‚Ä¢ manages PWG generator configurations as versioned code.

‚Ä¢ conducts testing and CI on PWG generator configurations.

For more details, see: https://github.com/AliceO2Group/O2DPG

Key directories:

‚Ä¢ MC/bin (workflow creation/execution)

‚Ä¢ MC/run (PWG-specific run scripts)

‚Ä¢ MC/config (PWG-specific generator configurations)

19
Basics of O2DPG-MC

‚Ä¢ Running an MC job involves two distinct steps to separate configuration logic from execution logic.

‚Ä¢ Step One: Develop a valid and configured description of the MC job, referred to as a ‚Äúworkflow.‚Äù

‚Ä¢ Step Two: Execute the MC job using a dynamic graph scheduler.

---

OUTPUT (AOD)

‚Ä¢ The workflow runner/executor assesses and constructs a DAG workÔ¨Çow on a compute node


‚Ä¢ At a minimum, it requires a workflow file and a target as inputs

${O2DPG_ROOT}/MC/bin/o2dpg_workflow_runner.py -f workflow.json -tt aod

‚ÄúRun the workflow up to the AOD task 
(assuming an 8-core CPU configuration)‚Äù

‚Ä¢ It supports checkpointing and incremental building

o2dpg_workflow_runner.py -f workflow.json -tt digi 
o2dpg_workflow_runner.py -f workflow.json -tt aod

‚ÄúFirst execute until digitization ‚Ä¶ then continue until AOD (without redoing tasks already completed!)‚Äù

---

"Run the workflow up to the AOD task (assuming an 8-core CPU setup)"

‚Ä¢ Checkpointing and incremental builds

‚Ä¢ Convert the DAG into a standalone shell script

o2dpg_workflow_runner.py -f workflow.json -tt digi
o2dpg_workflow_runner.py -f workflow.json -tt aod

"Run the workflow until digitization first, then proceed to AOD without repeating completed tasks!

o2dpg_workflow_runner.py -f workflow.json -tt aod
‚Äî-produce-script my_script.sh

‚Ä¢ Many additional useful features


"Generate a simple shell script for the workflow up to the AOD stage"

‚Ä¢ The usual o2dpg_workflow_runner.py ‚Äî-help command provides a list of available options

23
O2DPG MC workflows: Requirements

‚Ä¢ Valid AliEn tokens are necessary to execute (for accessing CCDB objects)


‚Ä¢ Experts can bypass this by using CCDB snapshots


‚Ä¢ O2DPG MC workflows are designed to operate in an 8-core, 16GB RAM environment, mirroring the standard resources on the GRID

---

‚Ä¢ Step Two: Execute the MC job using a dynamic graph scheduler

WorkÔ¨Çow creator

WorkÔ¨Çow executor

Output (AOD) 

20
Fundamentals of O2DPG-MC

‚Ä¢ Running an MC job involves a two-part procedure to separate configuration logic from execution logic


‚Ä¢ Step One: Develop a properly configured description of the MC job referred to as a ‚ÄúworkÔ¨Çow‚Äù


‚Ä¢ Step Two: Execute the MC job with a dynamic graph scheduler

WorkÔ¨Çow creator

WorkÔ¨Çow executor

Output (AOD) 

Formulates a coherent and integrated MC 
workÔ¨Çow in a directed-acyclic-graph (DAG) format, described as a JSON file, which models task dependencies


Adapts the MC workÔ¨Çow based on key user parameters

‚Ä¢ Collision system, generators, interaction rate, number of 
timeframes

workÔ¨Çow.json

20
Fundamentals of O2DPG-MC

‚Ä¢ Running an MC job involves a two-part procedure to separate configuration logic from execution logic


‚Ä¢ Step One: Develop a properly configured description of the MC job referred to as a ‚ÄúworkÔ¨Çow‚Äù


‚Ä¢ Step Two: Execute the MC job with a dynamic graph scheduler

---

‚Ä¢ Previous documentation in AliceO2: DetectorSimulation.md

‚Ä¢ Information on O2DPG can be found in WorkÔ¨ÇowRunner.md

‚Ä¢ Various examples are available at O2/SimExamples or nightly-tests

3
Contact information

‚Ä¢ How to reach the simulation developers


‚Ä¢ Simulation e-group for meeting announcements, plus WP12 meetings


‚Ä¢ Prefer collaborative Mattermost channels: O2-simulation and O2DPG


‚Ä¢

JIRA tickets for feature requests or bug reports (components: simulation or O2DPG)


‚Ä¢ Where to find simulation information


‚Ä¢ A new documentation project: https://aliceo2group.github.io/simulation/


‚Ä¢ Previous documentation in AliceO2: DetectorSimulation.md

‚Ä¢ Some information in O2DPG: WorkÔ¨ÇowRunner.md

‚Ä¢ Various examples at O2/SimExamples or nightly-tests

üëà Still in early stages: give feedback, ask questions, contribute!

3
Software environment reminder

local build

aliBuild build O2sim -‚Äìdefaults o2 

alienv enter O2sim/latest

nightly precompiled builds (CentOS)

---

14
External Generators

üëâ Example: Run/SimExamples/
AliRoot_AMPT

üëâ Example: Run/SimExamples/
AliRoot_Hƒ≥ing

‚Ä¢ In O2, direct integration of specific generators, aside from Pythia, is minimal to decouple PWG generator code and configurations from the data-taking process.

‚Äúinvoke o2-sim with -g external and specify the external file and function name‚Äù

o2-sim -n 10 -g external --configKeyValues 
'GeneratorExternal.fileName=myGen.C;GeneratorExternal.funcName="gen(5020)"'

‚Ä¢ This avoids the need for recompilation.

‚Ä¢ Instead, ‚Äúexternal‚Äù generators can be interfaced in o2-sim through just-in-time ROOT macros that, for example, implement a GeneratorTGenerator class.

‚Ä¢

configure the generator at ‚Äúuse-time‚Äù in C++.

‚Ä¢

the generator setup turns into a ‚Äúconfiguration problem.‚Äù

‚Ä¢

this approach is utilized to set up PWG-specific generation within the O2DPG production system.

‚Ä¢

reference the PWGDQ cocktail generator 

‚Äúsnippet of the ROOT macro file myGen.C‚Äù

---

Sandro Wenzel, 26.4.2023

Running Run3 Simulations

ALICE Analysis Tutorial
Agenda

‚Ä¢ Gain an overview of the ALICE Run3 simulation environment and understand the necessary steps

‚Ä¢ Familiarize yourself with basic functionalities of o2-sim, including event generation and transport simulation

‚Ä¢ Learn about the use and configuration of basic event generators

‚Ä¢ Be introduced to O2DPG ‚Äì the official integrated MC production pipeline from event generation to AOD and analysis

Introductory overview for ‚Äúanalysts‚Äù; Additional details in PWG tutorials

2
Contact Information

‚Ä¢ Learn how to contact the simulation developers

‚Ä¢ Use the simulation e-group for meeting announcements and participate in WP12 meetings

‚Ä¢ Utilize collaborative Mattermost channels (preferable over private email): O2-simulation and O2DPG

‚Ä¢ Report feature requests or bug reports via JIRA tickets (for simulation or O2DPG components)

‚Ä¢ Find information about the simulation

‚Ä¢ Refer to the new documentation project: https://aliceo2group.github.io/simulation/

‚Ä¢ Previous documentation in AliceO2: DetectorSimulation.md

---

‚Ä¢ Run numbers should also be utilized in non-data-taking anchored simulations


‚Ä¢ A list of predefined run numbers for Monte Carlo simulations is documented here: https://twiki.cern.ch/twiki/bin/view/ALICE/O2DPGMCSamplingSchema


‚Ä¢ For instance, in a PbPb simulation with a magnetic field of -0.5T, a run number of 310000 can be applied


‚Ä¢ This should ideally retrieve CCDB objects suitable for PbPb 22
MC workflow execution: basic features

O2DPG/MC/bin/o2dpg_workflow_runner.py

WorkÔ¨Çow generator

WorkÔ¨Çow runner

Output 
(AOD) 

‚Ä¢ The workflow runner/executor assesses and constructs a DAG workÔ¨Çow on a compute node


‚Ä¢ At a minimum, it requires the workflow file and a target as inputs

${O2DPG_ROOT}/MC/bin/o2dpg_workflow_runner.py -f workflow.json -tt aod

‚ÄúRun the workflow up to the aod task 
(assuming an 8-core CPU setup)‚Äù

23
MC workflow execution: basic features

O2DPG/MC/bin/o2dpg_workflow_runner.py

WorkÔ¨Çow generator

WorkÔ¨Çow runner

Output 
(AOD) 

‚Ä¢ The workflow runner/executor assesses and constructs a DAG workÔ¨Çow on a compute node