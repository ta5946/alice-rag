## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/GRID/utils/jdl_to_script.py

**Start chunk id:** 13d5e95750f099b4ab6c372594d2e564d232f6b1297a4065286e2e7f2d87cb05

## Content

DOCUMENT:
    f = open(jdlfile)
    if f:
        linelist = [line.rstrip('\n') for line in f if "LPMMetaData" not in line]
        # merge lines into a single string
        flatjdl = "".join(linelist)
        # separate the string by ';' (but ignore any within strings by removing LPMMetaData)
        statements = flatjdl.split(";")
        for s in statements:
            if s:
                key, value = s.split(" = ")
                parsed_dict[key.strip()] = value.strip()
        
        print(parsed_dict)
        f.close()
        return parsed_dict
    
    else:
        print("Could not open file")
        return {}  

  # generates a bash script to run the jdl locally
def constructRuntimeScript(jdldict):
  script=["#!/usr/bin/env bash"]
  # we need to set up the correct software environment
  packagelist = toList(jdldict['Packages'])
  packagestring = ",".join(packagelist)
  script.append("/cvmfs/alice.cern.ch/bin/alienv printenv " + packagestring + " &> environment")
  script.append("source environment")

---

# converts a JDL list into a python list
def toList(token):
  if token == None or len(token)==0:
    return token
  if token[0]=='{' and token[-1]=='}':
    inner=token[1:-1]
    # be cautious, this could fail if a comma is inside a string
    return [l.lstrip().rstrip() for l in inner.split(",")]
  return [token]

def cleanFileName(filename):
  # eliminate " and 'LF:' from alien file names
  return filename.replace('LF:','').replace('"','')

def removeQuote(token):
  return token.replace('"','')

---

DOCUMENT:
    def removeQuote(token):
        return token.replace('"','')

# retrieves a JDL for a specified PROC ID and saves it to a local file
def fetchJDL(alien_proc_id):
    print('Directly fetching JDL from ALIEN')
    # using alien.py's functionality
    filename = "jdl_local_" + alien_proc_id + ".jdl"
    cmd = "alien.py ps --jdl " + alien_proc_id + " > " + filename
    proc = subprocess.Popen([cmd], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    out, err = proc.communicate()
    if proc.returncode == 0:
        return filename
    print('Fetching JDL failed. Ensure you have access to jalien')
    return None

# let's begin with a JDL parser
# the function tokenizes the JDL and returns a dictionary of keys and values
# it assumes the JDL is syntactically correct and in the standard Alien format (no comments, etc.)
def parseJDL(jdlfile, proc_id = -1):
    parsed_dict = {}
    if jdlfile is None or len(jdlfile) == 0:
        return parsed_dict

---

DOCUMENT:
    return script

# executes the script stored in a line by line list
def convertToScript(scriptlist, outfilename):
  f=open(outfilename,'w')
  if f:
    for line in scriptlist:
      f.write(line + '\n')
    f.close()
    # make the script executable
    os.system("chmod +x " + outfilename)
    # this is more complex: os.chmod(outfilename, stat.S_IEXEC | stat.S)

jdlfilename=''
if args.from_proc_id!=None:
  jdlfilename=fetchJDL(args.from_proc_id)
else:
  jdlfilename=args.jdl

jdl_dict = parseJDL(jdlfilename)
print (jdl_dict)
script = constructRuntimeScript(jdl_dict)
convertToScript(script, args.o)

---

#!/usr/bin/env python3

# Generates a local shell script that simulates the execution of a JDL on the GRID.
# This is helpful for local debugging of failing GRID jobs.

# initiated on 01.12.2022 by Sandro Wenzel

import argparse
import os, stat
import subprocess

parser = argparse.ArgumentParser(description='Create a local shell script from an ALIEN JDL')

# the run number for data acquisition or the default if unspecified
parser.add_argument('--jdl', type=str, help="Local JDL file")
parser.add_argument('--from-proc-id', type=str, help="Extract the JDL directly from a known ALIEN PROCID")
parser.add_argument('-o', type=str, help="Output filename for the generated shell script")
args = parser.parse_args()
print(args)

---

# now fetch all necessary input files
# a) the executable
script.append("alien.py cp " + cleanFileName(jdldict['Executable']) + " file:./")
# b) any additional inputs
for f in toList(jdldict['InputFile']):
    script.append("alien.py cp " + cleanFileName(f) + " file:./")

# export the original PROC if available
if args.from_proc_id != None:
    script.append("export ALIEN_PROC_ID="+args.from_proc_id)

# export all variables specified in the JDL
for env in toList(jdldict['JDLVariables']):
    var=removeQuote(env).lstrip().rstrip()
    script.append("export ALIEN_JDL_" + var.upper() + "=" + jdldict[var])

# execute the script --> run the executable with arguments -- and remove the path
revexec=removeQuote(jdldict['Executable'][::-1])
firstslashindex=revexec.find('/')
nopathexec=revexec[0:firstslashindex][::-1]
script.append("chmod +x " + nopathexec)
script.append("./" + nopathexec + " " + jdldict.get('Arguments',''))

return script