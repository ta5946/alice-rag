## Metadata

**Document link:** https://github.com/AliceO2Group/simulation/blob/main/docs/transport/mckine.md

**Start chunk id:** 0c55483e01d1ae4077cee79b9057d6b312aa129c334a940b958bee083252cb91

## Content

```
// iterate through all events in the file
for (int event = 0; event < reader.getNEvents(0); ++event) {
  // obtain all Monte Carlo tracks for this event; note that this is a shortened version of
  // std::vector<MCTrack> const& tracks = reader.getTracks(source, event);
  std::vector<MCTrack> const& tracks = reader.getTracks(event);

  // process the tracks
}
Next to handling pure kinematic files, the MCKinematicsReader provides the capability to fetch tracks based on a specific MC label.

Within the track loop, a variety of analyses can be performed:
* examine PDG codes,
* review kinematic details or production vertices,
* assess parent-child relationships between particles,
* etc.
A range of methods exists to access properties of an `o2::MCTrack` object, as detailed in the [source code](https://github.com/AliceO2Group/AliceO2/blob/dev/DataFormats/simulation/include/SimulationDataFormat/MCTrack.h).
```

---

## Navigating the Kinematics File

Typically, the file is named `<prefix>_Kine.root` and includes a tree called `o2sim`. The branch that is most crucial to examine is `MCTracks`, which stores per event `std::vector<o2::MCTrack>`. An initial example macro might start like this:
```cpp
int analyseKine(const char* path)
{
    TFile inputKine(path, "READ");
    auto tree = (TTree*)inputKine.Get("o2sim");
    std::vector<o2::MCTrack>* tracks{};
    tree->SetBranchAddress("MCTrack", &tracks);
    for (int ev = 0; ev < tree->GetEntries(); ++ev) {
        tree->GetEntry(ev);
        for (auto& track : *tracks) {
            // perform actions for each track
        }
    }

    return 0;
}
```

Another recommended approach is to utilize the MCKinematicsReader class:
```c++
// initialize the reader from the transport kinematics file (assuming the prefix is o2sim)
o2::steer::MCKinematicsReader reader("o2sim", o2::steer::MCKinematicsReader::Mode::kMCKine);
```

---

It is highly beneficial to inspect the contents, especially if issues with the simulation pipeline are anticipated later, such as:
* a particular particle being absent,
* certain tracks having unusual kinematics,
* expected energy depositions being incorrect or missing,
* etc.
In fact, it is essential to verify that the initial stages of the simulation are correct before running a full simulation or a large-scale production.

## Navigating the Kinematics File

---

Here are some concise examples with more detailed scenarios.

### Verify if a track has hits on the left

This segment illustrates how to determine if a track left any hits, and specifically, if it left a hit in the FV0 detector.
```c++
// Initialize the reader from the transport kinematics file (assuming the prefix is "o2sim")
o2::steer::MCKinematicsReader reader("o2sim", o2::steer::MCKinematicsReader::Mode::kMCKine);

// This assumes a straightforward signal MC, meaning one generator and no embedding
int source = 0;
```

---

## Simulate Based on MC Kinematics

If you aim to introduce the same initial particles as in a previous simulation, refer to the [generator section](../generators/generatorso2.md#extkino2).

---

// assuming a basic signal MC scenario, meaning one generator with no embedding
int source = 0;

// iterate through each event in the file
for (int event = 0; event < reader.getNEvents(0); ++event) {
  // retrieve all Monte Carlo tracks for the current event; note that this is a shorthand for
  // std::vector<MCTrack> const& tracks = reader.getTracks(source, event);
  std::vector<MCTrack> const& tracks = reader.getTracks(event);
  o2::dataformats::MCEventHeader const& header = reader.getMCEventHeader(source, event);
  // determine the detector mask for the event
  std::vector<int> const& detId2HitBitLUT = header.getDetId2HitBitLUT();
  // analyze the tracks
  for (auto& track : *tracks) {
    if (track.hasHits()) {
      // perform an action if the track has at least one hit
    }
    if (track.leftTrace(o2::detectors::DetID::FV0, detId2HitBitLUT)) {
      // execute a specific action if there is a hit in FV0
    }
  }
}
```

## Simulate based on MC kinematics

```

---

---
sort: 2
title: MC Kinematics
---

# MC Kinematics

The MC kinematics is consistently generated whenever `o2-sim` is executed. It includes the initial kinematic data of both primaries (originating from the [generator](../generators/)) and secondaries (produced during the transport process) at their respective production vertices. This also encompasses particles that do not undergo transport, such as intermediary particles from the generator like quarks and gluons, or very short-lived particles generated during the transport phase.

---

A helpful tool is the `o2::mcutils::MCTrackNavigator` class, primarily comprising static functions designed for navigating through tracks, particularly for resolving parent-child relationships. For example, to find the child tracks, you can use the following code within a track loop:

```cpp
// within the track loop
auto child0 = o2::mcutils::MCTrackNavigator::getDaughter0(track, *tracks);
auto child1 = o2::mcutils::MCTrackNavigator::getDaughter1(track, *tracks);
```

This class offers many additional useful methods, as detailed in the [source code](https://github.com/AliceO2Group/AliceO2/blob/dev/DataFormats/simulation/include/SimulationDataFormat/MCUtils.h).

## Specific Examples

Here are a few small snippets with more specific examples:

### Checking if a track left hits

For instance, to check if a track left any hits, you might use a method like:

```cpp
bool hasLeftHits = o2::mcutils::MCTrackNavigator::checkLeftHits(track, *tracks);
```