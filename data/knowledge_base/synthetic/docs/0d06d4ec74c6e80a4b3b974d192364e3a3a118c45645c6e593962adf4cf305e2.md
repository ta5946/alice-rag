## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/UTILS/Parsers/READMEtreeFastCache.md

**Start chunk id:** 0d06d4ec74c6e80a4b3b974d192364e3a3a118c45645c6e593962adf4cf305e2

## Content

```

### 🖊️ Parameters for `registerMapND`
```cpp
int registerMapND(
  const std::string& uniqueName,       // Unique identifier for the map
  TTree* tree,                   // Source tree
  const std::vector<std::string>& exactDimNames, // Exact coordinate names
  const std::string& nearestDimName,             // Nearest coordinate dimension (e.g., time)
  const std::string& valueVariable,               // Variable to interpolate
  const std::string& treeSelection               // Selection criteria for the tree
);
```

### 🖊️ Parameters for `setNearestNDAlias`
```cpp
void setNearestNDAlias(
  TTree* targetTree,                          // Target tree for the alias
  const std::string& aliasName,        // Name of the alias to be created
  const std::string& registeredMapName,          // Name used in registration
  const std::string& nearestCoordinateExpression, // Expression for nearest match
  const std::vector<std::string>& exactCoordinateExpressions // Expressions for exact matches
);
```

---

# 📦 Fast Lookup and Interpolation System for ROOT Trees

This repository includes ROOT macros for quickly accessing and interpolating values from TTrees, utilizing:

- `treeFastCache1D.C`: A 1D cache with nearest-neighbor lookup
- `treeFastCacheND.C`: An ND cache with exact matches in N–1 dimensions and nearest-neighbor in 1 dimension

These macros are tailored for real-time analysis with `TTree::Draw`, such as QA plots, calibration overlays, or smoothed time series.

---

## 🔹 `treeFastCache1D.C`

### ✅ Features

- Registers 1D lookup maps from TTrees
- Implements nearest-neighbor lookup using `std::map<double, float>`
- Supports registration by ID or string name
- Enables fast evaluation during `TTree::Draw`
- Integrates with aliases for interactive sessions

### 🧪 Example

```cpp
TTree* tree = ...;
int mapID = registerMap1DByName("dcar_vs_time", "time", "dcar_value", tree, "subentry==127");

tree->SetAlias("dcar_smooth", ("getNearest1D(time," + std::to_string(mapID) + ")").c_str());
tree->Draw("dcar_value:dcar_smooth", "indexType==1", "colz", 10000);
```

---

---

## 📜 License

Meant for internal physics studies. No guarantees are provided.

---

For further information, refer to the comments and examples within `treeFastCache1D.C` and `treeFastCacheND.C`.

---

---

## 🔸 `treeFastCacheND.C`

### ✅ Features

- ND caching that:
  - Offers **exact match** in N–1 dimensions
  - Provides **nearest-neighbor** lookup in 1 dimension (e.g., `time`)
- Employs full `double` precision for all keys
- Supports `TTree::Draw` via aliases
- Registers by name using a hashed map ID
- Features a variadic interface for direct application

### 🧪 Example: Time Series

```cpp
TTree* tree = ...;
int mapID = registerMapND("dcar_vs_time", tree, {"subentry"}, "time", "mTSITSTPC.mDCAr_A_NTracks_median", "1");
setNearestNDAlias(tree, "dcar_smooth", "dcar_vs_time", "time", {"subentry"});

tree->Draw("mTSITSTPC.mDCAr_A_NTracks_median:dcar_smooth", "indexType==1", "colz", 10000);
```

---

### ⚡️ Alternative: Direct expression
```cpp
tree->Draw("val:getNearestND(time,mapID,subentry)", ...);
```

---

## 📊 Internal Storage

### 1D:
```cpp
std::map<int, std::map<double, float>> registeredMaps;
std::map<std::string, int> mapIDByName;
```

### ND:
```cpp
std::map<int, std::map<std::vector<double>, std::map<double, double>>> ndCaches;
std::map<std::string, int> ndIDByName;
```

---

## 📌 Best Practices

- Utilize aliases to streamline `TTree::Draw` expressions
- Opt for double precision to ensure stability in nearest neighbor searches
- Store maps using string names for easier re-registration
- Opt for `setNearestNDAlias()` over direct `getNearestND(...)` for better readability

---

## 📤 Future Ideas

- Incorporate optional interpolation methods (linear, spline)
- Develop strategies for handling unmatched keys gracefully
- Introduce caching diagnostics and summary statistics
- Create a C++ class wrapper for improved lifecycle management and reusability

---

## 📜 License

Designed for use in internal physics analyses. No warranty is provided.