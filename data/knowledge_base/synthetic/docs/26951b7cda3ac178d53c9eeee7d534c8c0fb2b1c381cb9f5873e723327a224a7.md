## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/test/common/utils/utils.sh

**Start chunk id:** 26951b7cda3ac178d53c9eeee7d534c8c0fb2b1c381cb9f5873e723327a224a7

## Content

DOCUMENT:
    get_workflow_creation_from_script()
    {
        # Extract the line in the script responsible for creating a workflow
        local wf_script=${1}
        # Identify the line where the workflow is defined
        local look_for="o2dpg_sim_workflow.py"
        # Construct the entire line, removing line breaks, from the file
        local string_wo_line_breaks=
        while read -r line ; do
            [[ "${line}" == *"${look_for}"* ]] && has_started=1
            [[ "${has_started}" != "1" ]] && continue
            string_wo_line_breaks+=${line%%\\}
            [[ "${line}" == *"\\"* ]] && string_wo_line_breaks+=" "
            [[ "${line}" != *"\\"* ]] && break
        done < ${wf_script}
        echo ${string_wo_line_breaks}
    }

    make_wf_creation_script()
    {
        # The output should only include the workflow creation, excluding any runner or other elements

---

make_wf_creation_script()
{
    # The goal is to extract just the workflow creation, without running any additional scripts.

    # The strategy
    # Capture all lines until the first occurrence of the simulation workflow creation; then stop
    # This assumes that the workflow creation command is not nested within if-else statements or enclosed in another scope.
    # in
    local full_wf_script=${1}
    # out
    local out_script=${2}

    # Ensure the runner is not executed
    local look_for="o2dpg_sim_workflow.py"
    # Verify that the runner line is present; if not, the script will not execute
    local has_no_wf=1

    while read -r line ; do
        if [[ "${line}" == *"${look_for}"* ]] ; then
            has_no_wf=0
        fi
        if [[ "${has_no_wf}" == "0" ]] ; then
            break
        fi
        echo "${line}" >> ${out_script}
    done < ${full_wf_script}

    echo "$(get_workflow_creation_from_script ${full_wf_script})" >> ${out_script}
    return ${has_no_wf}
}

---

print_error_logs()
{
    local search_directory=${1}
    local search_pattern="TASK-EXIT-CODE: ([1-9][0-9]*)|[Ss]egmentation violation|[Ss]egmentation fault|Program crashed|[Ee]xception caught|\[FATAL\]|uncaught exception|\(int\) ([1-9][0-9]*)|fair::FatalException"
    local error_logs=$(find ${search_directory} -maxdepth 4 -type f \( -name "*.log" -or -name "*serverlog*" -or -name "*workerlog*" -or -name "*mergerlog*" \) | xargs grep -l -E "${search_pattern}" | sort)
    for el in ${error_logs} ; do
        echo_red "Error detected in log $(realpath ${el})"
        # display the match along with the preceding and following 10 lines
        grep -n -A 10 -B 10 -E "${search_pattern}" ${el}
    done
}

---

# verify the presence of unstaged changes and check if ALIBUILD_HEAD_HASH is unset, then compare against unstaged changes
# if there are unstaged changes and no user-specified head, leave it empty
[[ ! -z "$(git diff)" && -z ${ALIBUILD_HEAD_HASH+x} && -z ${O2DPG_TEST_HASH_HEAD+x} ]] && hash_head=""
# if there are unstaged changes and no user-specified base, set it to HEAD
[[ ! -z "$(git diff)" && -z ${ALIBUILD_HEAD_HASH+x} && -z ${O2DPG_TEST_HASH_BASE+x} ]] && hash_base="HEAD"
local paths=$(git diff --diff-filter=AMR --name-only ${hash_base} ${hash_head})
local absolute_paths=
for p in ${paths} ; do
    absolute_paths+="$(realpath ${p}) "
done
echo "${absolute_paths}"
}

---

#!/bin/bash

#
# Test utility functionality
#

# a global counter for tests
TEST_COUNTER=0

# Prepare some colored output
SRED="\033[0;31m"
SGREEN="\033[0;32m"
SYELLOW="\033[0;33m"
SEND="\033[0m"

echo_green()
{
    echo -e "${SGREEN}${*}${SEND}"
}


echo_red()
{
    echo -e "${SRED}${*}${SEND}"
}


echo_yellow()
{
    echo -e "${SYELLOW}${*}${SEND}"
}


remove_artifacts()
{
    [[ "${KEEP_ONLY_LOGS}" == "1" ]] && find . -type f ! -name '*.log' -and ! -name "*serverlog*" -and ! -name "*mergerlog*" -and ! -name "*workerlog*" -delete
}


git_get_changed_files()
{
    # in the Github CIs, environment variables provide the base and head hashes,
    # so use them if available
    # Otherwise, fall back to a few steps back
    local hash_base_user=${O2DPG_TEST_HASH_BASE:-"HEAD~1"}
    local hash_head_user=${O2DPG_TEST_HASH_HEAD:-"HEAD"}
    local hash_base=${ALIBUILD_BASE_HASH:-${hash_base_user}}
    local hash_head=${ALIBUILD_HEAD_HASH:-${hash_head_user}}

}