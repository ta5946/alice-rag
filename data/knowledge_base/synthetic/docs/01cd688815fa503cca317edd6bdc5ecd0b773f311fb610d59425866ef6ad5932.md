## Metadata

**Document link:** https://github.com/AliceO2Group/AliceO2/blob/dev/Detectors/TPC/calibration/doc/IDCWorkFlow.md

**Start chunk id:** 01cd688815fa503cca317edd6bdc5ecd0b773f311fb610d59425866ef6ad5932

## Content

# Shared memory size
ARGS_ALL="--shm-segment-size 50000000000"

# Proxy configuration
configProxy="name=readout-proxy,type=pull,method=bind,address=tcp://localhost:30453,rateLogging=1,transport=zeromq"

---

```bash
o2-tpc-idc-factorize                \
--crus=${crus}                      \ # expected CRUs
--timeframes ${nTFs}                \ # total number of time frames sent by o2-tpc-idc-distribute
--input-lanes ${lanes}              \ # total number of lanes defined in o2-tpc-idc-distribute
--groupPads "5,6,7,8,4,5,6,8,10,13" \ # number of pads grouped in the pad direction
--groupRows "2,2,2,3,3,3,2,2,2,2"   \ # number of pads grouped in the row direction
--nthreads-grouping 8               \ # number of threads for grouping
--nthreads-IDC-factorization 8      \ # number of threads for IDC factorization
--enablePadStatusMap true           \ # perform outlier filtering using the `IDC0`
--enable-CCDB-output true           \ # enable creation and sending of CCDB output and grouping of `IDCDelta`
--sendOutputFFT true                \ # send the output to the `o2-tpc-idc-ft-aggregator`
```

---

# Workflow for IDC Generation

The `o2-tpc-idc-test-ft` workflow can be used to generate `IDCs` as input for the `o2-tpc-idc-flp` workflow. These `IDCs` can either be created randomly from a Gaussian distribution or loaded from a `IDCGroup.root` file (`--load-from-file true`), which was previously written to file using the `o2-tpc-idc-flp` workflow (`o2-tpc-idc-flp --dump-idcs-flp true`).

``` bash
nTFs=1000 # number of TFs to generate
```

---

#### Factorization of `IDC`s
Convert the `IDC`s into `IDC0`, `IDC1`, and `IDCDelta`, and then carry out the averaging, grouping, and compression of `IDCDelta`. Grouping parameters can be configured using options like `--groupPads "..." --groupRows "..."`. For specialized grouping at the sector edges, use a configuration key such as `--configKeyValues 'TPCIDCGroupParam.groupPadsSectorEdges=32211'`.

---

```

#### Receive raw data

```bash
# define global parameters for the workflow
crus="0-359" # expect data from all CRUs in FLPs
lanes=2      # number of parallel devices for the factorization (at least 2 devices are recommended)
nTFs=1000    # number of TFs to be used for factorization and Fourier transform

# input addresses for the `IDC`s
loc="A:TPC/IDCGROUPA;A:TPC/IDCGROUPC"

# shared memory segment size
ARGS_ALL="--shm-segment-size 50000000000"
```

---

| o2-calibration-ccdb-populator-workflow --ccdb-path ccdb-test.cern.ch:8080 \
-b
```

```

---

# IDC Workflow (FLPs and Aggregator)
## FLPs

`IDC`s are integrated on the CRUs and transformed into a `std::vector<float>` through the `o2-tpc-idc-to-vector` workflow. `IDC1` are utilized for Fourier transform, with the resulting coefficients serving as input for space-charge correction. For synchronous reconstruction, `IDC1` are computed on the FLPs via the `o2-tpc-idc-flp` workflow and transmitted to the EPNs for FFT processing. The FFT is executed on the EPNs by the `o2-tpc-idc-ft-epn` workflow. Furthermore, `IDC`s are sent to an aggregator to factorize them for a specific calibration interval and subsequently perform the FFT. The factorized `IDC`s (`IDC0`, `IDC1`, `IDCDelta`) and the Fourier coefficients are then stored in the CCDB.

#### `IDC1` on FLPs
Parallelization can be achieved by dividing CRUs on an FLP into separate devices using `--lanes` or by utilizing time lanes with `--time-lanes`:

---

o2-raw-file-reader-workflow --detect-tf0 --shm-segment-size ${shm} --input-conf raw/TPC/tpcraw.cfg --loop ${nLoop} --max-tf 0 \
| o2-tpc-reco-workflow --input-type zsraw --output-type digits,disable-writer \
| o2-tpc-idc-integrate \
| o2-tpc-idc-flp \
--disableIDC0CCDB true \
--lanes 1 \
--enable-synchronous-processing true \
| o2-tpc-idc-distribute \
--timeframes ${nTFs} \
--condition-tf-per-query -1 \
--send-precise-timestamp true \
| o2-tpc-idc-factorize \
--timeframes ${nTFs} \
--nthreads-grouping 4 \
--configKeyValues 'TPCIDCGroupParam.groupPadsSectorEdges=32211' \
--dump-IDCs true \
--dump-IDCDelta \
--enable-CCDB-output true \
--sendOutputFFT true \
| o2-tpc-idc-ft-aggregator \
--rangeIDC 200 \
--nFourierCoeff 40 \

---

```bash
crus="0-179" # restrict to CRUs from one TPC side
o2-tpc-idc-test-ft --timeframes 200 --delay true --iter 0 --crus $crus --dump-IDC0
o2-tpc-idc-test-ft --timeframes 200 --delay true --iter 1 --crus $crus
```

---

```bash
o2-tpc-idc-flp                       \ # calculation of `IDC1`
--lanes 2                             \ # the FLP's CRUs will be divided into two parallel processing streams
--time-lanes 1                        \ # the number of time lanes is set to one
--disableIDC0CCDB true                \ # `IDC0` will not be loaded from the CCDB, used for `IDC1` normalization
--crus ${crus}                        \ # the expected CRUs are specified
--enable-synchronous-processing true  \ # synchronous processing is enabled for `IDC1` calculation
```

#### Output Proxy
Transmitting the `IDC`s from the FLPs to the aggregator node:

```bash
loc="'downstream:TPC/IDCGROUPA;downstream:TPC/IDCGROUPC'" # destination address for `IDC`s

o2-dpl-output-proxy                                                                                        \
--channel-config "name=downstream,method=connect,address=tcp://localhost:30453,type=push,transport=zeromq" \
--dataspec ${loc} -b
```

## Aggregator

---

## Aggregator

At the aggregator node, the `IDC`s from the FLPs are gathered by an input proxy and combined until data from all specified CRUs are collected. Upon receiving `IDC`s for a certain number of TFs, the factorization of the `IDC`s, the averaging or grouping of the factorized `IDCDelta`, and the FFT of the factorized `IDC1` are carried out. These factorized `IDC`s, along with the grouping parameters and the Fourier coefficients, can be stored in the CCDB via the `o2-calibration-ccdb-populator-workflow` workflow.

#### Define global parameters for the workflow:
```bash
crus="0-359"                # anticipate data from all CRUs from FLPs
lanes=2                     # number of parallel devices for factorization (at least 2 devices are recommended)
nTFs=1000                   # number of TFs utilized for factorization and Fourier transform
url="http://localhost:8080" # CCDB URI: for local CCDB or use "http://ccdb-test.cern.ch:8080"
```

---

o2-dpl-raw-proxy ${ARGS_ALL}        \
--dataspec ${loc}                   \
--channel-config "${configProxy}"   \
| o2-tpc-idc-distribute ${ARGS_ALL} \
--crus=${crus}                      \
--timeframes ${nTFs}                \
--output-lanes ${lanes}             \
| o2-tpc-idc-factorize ${ARGS_ALL}  \
--crus=${crus}                      \
--timeframes ${nTFs}                \
--input-lanes ${lanes}              \
--nthreads-grouping 8               \
--nthreads-IDC-factorization 8      \
--nTFsMessage 250                   \
--enablePadStatusMap true           \
--enable-CCDB-output true           \
--sendOutputFFT true                \
--configKeyValues 'TPCIDCGroupParam.groupPadsSectorEdges=32211' \
| o2-tpc-idc-ft-aggregator ${ARGS_ALL} \
--rangeIDC 200                         \
--nFourierCoeff 40                     \
--timeframes ${nTFs}                   \
--nthreads 8                           \
| o2-calibration-ccdb-populator-workflow --ccdb-path ccdb-test.cern.ch:8080 \
-b

---

<!-- doxy
\page refTPCcalibrationIDC IDC Calibration
/doxy -->

# IDCs

A concise guide on executing the `IDC` workflow on FLPs and the aggregator node, as well as running it locally with simulated digits as input.

#### Definition of `IDC`s:
`IDC`: $ I(r,\phi,t) $ \
`IDC0`: $I_0(r,\phi) = \langle I(r,\phi,t) \rangle _{t=1000\text{ TFs}}$ \
`IDC1`: $I_1(t) = \langle I(r,\phi,t) / I_0(r,\phi) \rangle _{r,\phi}$ \
`IDCDelta`: $ \Delta I(r,\phi,t) = I(r,\phi,t) / \left[ I_0(r,\phi) \cdot I_1(t) \right] $

# IDC Workflow (FLPs and Aggregator)
## FLPs

---

# IDC Workflow Utilizing Simulated Digits
One can utilize simulated raw digits as input or employ the `o2-tpc-idc-test-ft` workflow to generate random `IDC`s or load `IDC`s from an input file (and perform some randomization).

### Simulate the Input
Run an `o2-sim` simulation to create digits and raw digits (for example):

```bash
# executing o2-sim
o2-sim -g pythia8pp -n 600 -m TPC [ PIPE ITS ]

# generating TPC digits at a 5MHz interaction rate
o2-sim-digitizer-workflow -b -q --onlyDet TPC --disable-mc --TPCuseCCDB --shm-segment-size $((8<<35)) --interactionRate 5000000

# to produce raw data
o2-tpc-digits-to-rawzs -i tpcdigits.root -o raw/TPC
```

Initiate the following workflows to perform the factorization of the `IDC`s, the grouping of `IDCDelta`, FFT on the aggregator and EPN, and to store the output in the CCDB and local files:

```bash
shm="50000000000"
nTFs=1  # consider only the first TF
nLoop=1 # the number of loops over the data
```

---

```markdown
## Unit test for FFT

    --nTFsMessage 250                   \
| o2-tpc-idc-ft-aggregator          \
--rangeIDC 200                      \
--nFourierCoeff 40                  \
| o2-tpc-idc-ft-epn                 \
--rangeIDC 200                      \
--nFourierCoeff 40                  \
--severity warning                  \
-b
```

---

o2-tpc-idc-test-ft                  \
--dropTFsRandom 20                  \ # randomly drop every n-th TF
--delay true                        \
--load-from-file true               \
--only-idc-gen true                 \
--timeframes ${nTFs}                \
| o2-tpc-idc-flp                    \
--disableIDC0CCDB true              \
--lanes 1                           \
--enable-synchronous-processing true \
--severity warning                  \
| o2-tpc-idc-distribute             \
--timeframes ${nTFs}                \
--condition-tf-per-query -1         \
--send-precise-timestamp true       \
--severity warning                  \
| o2-tpc-idc-factorize              \
--timeframes ${nTFs}                \
--nthreads-grouping 1               \
--configKeyValues 'TPCIDCGroupParam.groupPadsSectorEdges=32211' \
--enable-CCDB-output true           \
--sendOutputFFT true                \
--nTFsMessage 250                   \
| o2-tpc-idc-ft-aggregator          \

---

#### FFT
Receive `IDC1` from the `o2-tpc-idc-factorize` and execute the FFT on `IDC1`:

```bash
o2-tpc-idc-ft-aggregator \
--rangeIDC 200           \ # the number of `IDC1` utilized during the FFT per TF
--nFourierCoeff 40       \ # the number of Fourier coefficients per TF that will be stored in the CCDB
--inputLanes ${lanes}    \ # the number of lanes specified in `o2-tpc-idc-distribute`
--nthreads 8             \ # the number of threads used for the FFT
```

### Summary
All the necessary steps to be executed (on a local machine):

#### Send raw data

```bash
# FLPs
crus="0-359"
loc="'downstream:TPC/IDCGROUPC;downstream:TPC/IDCGROUPA'"

pathToRawData="/../path/to/data/"
```

---

To evaluate and contrast the fourier coefficients computed on the aggregator for a specified integration interval with those calculated on the EPNs per TF, the `o2-tpc-idc-test-ft` tool can be utilized. Initially, `IDC0` are computed and saved to a file. Subsequently, in another iteration, these `IDC0` are employed in the `o2-tpc-idc-flp` workflow for `IDC` normalization and `IDC1` calculation. The `IDC1` are then passed to the `o2-tpc-idc-ft-epn` workflow for performing the FFT.

The `IDC`s from the `o2-tpc-idc-flp` workflow are directed to the `o2-tpc-idc-factorize` workflow, where factorization and `IDC1` calculation occur and are then forwarded to the `o2-tpc-idc-ft-aggregator` workflow, which conducts the FFT.

Ultimately, the fourier coefficients derived from the `o2-tpc-idc-ft-epn` workflow are compared with those from the `o2-tpc-idc-ft-aggregator` workflow.

---

```
--rangeIDC 200                      \
--nFourierCoeff 40                  \
--dump-coefficients-agg true        \
| o2-tpc-idc-ft-epn                 \
--rangeIDC 200                      \
--nFourierCoeff 40                  \
--dump-coefficients-epn true        \
-b
```

---

#### Input proxy
Handling the `IDC`s from the FLPs:

```bash
# specifying locations for `IDC`s
loc="A:TPC/IDCGROUPA;A:TPC/IDCGROUPC"

# executing the input proxy
o2-dpl-raw-proxy  \
--dataspec ${loc} \
--channel-config "name=readout-proxy,type=pull,method=bind,address=tcp://localhost:30453,rateLogging=1,transport=zeromq"
```


#### Distribute received `IDC`s from proxy
Receiving the `IDC`s from the proxy and distributing them to the `o2-tpc-idc-factorize` workflow for factorization, based on the specified number of lanes. Additionally, checks are performed to ensure no data is dropped; if data is lost, dummy data is sent in its place:

```bash
o2-tpc-idc-distribute  \
--crus=${crus}         \ # expected CRUs
--timeframes ${nTFs}   \ # number of timeframes to be sent to one factorization device
--output-lanes ${lanes}  # number of output lanes for parallel factorization
```