## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/DATA/production/o2dpg_qc_postproc_workflow.py

**Start chunk id:** 196ed8f298acbb457c3cb42c55a45cc6a3a2ce00abb88b8112ab09a158a1f614

## Content

## The list of QC Post-processing workflows, add the new ones below
  add_QC_postprocessing('example', 'json://${O2DPG_ROOT}/DATA/production/qc-postproc-async/example.json', needs=[], run_specific=False, period_specific=True, pass_specific=True)
  add_QC_postprocessing('EMC', 'json://${O2DPG_ROOT}/DATA/production/qc-postproc-async/emc.json', needs=[], run_specific=False, period_specific=True, pass_specific=True)
  add_QC_postprocessing('MCH', 'json://${O2DPG_ROOT}/DATA/production/qc-postproc-async/mch.json', needs=[], run_specific=True, period_specific=True, pass_specific=True)
  add_QC_postprocessing('ZDC', 'json://${O2DPG_ROOT}/DATA/production/qc-postproc-async/zdc.json', needs=[], run_specific=True, period_specific=True, pass_specific=True)

  return stages


def main() -> int:
  
  parser = argparse.ArgumentParser(description='Generate the ALICE data QC postprocessing workflow')

---

# dynamically load necessary utilities
module_name = "o2dpg_workflow_utils"
spec = importlib.util.spec_from_file_location(module_name, join(O2DPG_ROOT, "MC", "bin", "o2dpg_workflow_utils.py"))
o2dpg_workflow_utils = importlib.util.module_from_spec(spec)
sys.modules[module_name] = o2dpg_workflow_utils
spec.loader.exec_module(o2dpg_workflow_utils)
from o2dpg_workflow_utils import createTask, dump_workflow

def getDPL_global_options(bigshm=False, noIPC=None):
   common = "-b --run --driver-client-backend ws:// "
   if noIPC:
      return common + " --no-IPC "
   if bigshm:
      return common + " --shm-segment-size ${SHMSIZE:-50000000000} "
   else:
      return common

qcdir = "QC"
def QC_postprocessing_workflow(runNumber, periodName, passName, qcdbUrl):

  stages = []

---

## Incorporates a postprocessing quality control workflow
  # taskName       - the name of the QC workflow
  # qcConfigPath   - the path to the QC configuration file
  # needs          - a list of tasks that must be completed prior to this one (e.g., another workflow might need to finish before this one starts)
  # runSpecific    - if set to true, a specific run number is included in the QC config, meaning the post-processing should focus only on objects from this run
  # periodSpecific - if set to true, a specific period name is included in the config, so the post-processing should cover objects only from this period
  # passSpecific   - if set to true, a specific pass name is included in the config, ensuring the post-processing covers objects only from this pass
  def add_QC_postprocessing(taskName, qcConfigPath, needs, runSpecific, periodSpecific, passSpecific):
    task = createTask(name=taskName, needs=needs, cwd=qcdir, lab=["QC"], cpu=1, mem='2000')

---

parser.add_argument('--noIPC',help='disable shared memory in DPL')
parser.add_argument('-o',help='output workflow file', default='workflow.json')
parser.add_argument('--run',help="Run number (0 for any run)", default=0)
parser.add_argument('--periodName',help="Period name", default='')
parser.add_argument('--passName',help="Pass name", default='')
parser.add_argument('--qcdbUrl',help="Quality Control Database URL", default='ccdb-test.cern.ch:8080')

args = parser.parse_args()
print(args)

if not isdir(qcdir):
    mkdir(qcdir)

workflow = {}
workflow['stages'] = QC_postprocessing_workflow(runNumber=args.run, periodName=args.periodName, passName=args.passName, qcdbUrl=args.qcdbUrl)

dump_workflow(workflow["stages"], args.o)

return 0


if __name__ == '__main__':
  sys.exit(main())

---

DOCUMENT:
    task = createTask(name=taskName, needs=needs, cwd=qcdir, lab=["QC"], cpu=1, mem='2000')
    overrideValues = '--override-values "'
    overrideValues += f'qc.config.database.host={qcdbUrl};'
    overrideValues += f'qc.config.Activity.type=PHYSICS;'
    overrideValues += f'qc.config.Activity.number={runNumber};' if runSpecific else 'qc.config.Activity.number=0;'
    overrideValues += f'qc.config.Activity.periodName={periodName};' if periodSpecific else 'qc.config.Activity.periodName=;'
    overrideValues += f'qc.config.Activity.passName={passName};' if passSpecific else 'qc.config.Activity.passName=;'
    overrideValues += '"'
    task['cmd'] = f'o2-qc --config {qcConfigPath} ' + overrideValues + ' ' + getDPL_global_options()
    stages.append(task)

---

#!/usr/bin/env python3

#
# This script generates the QC finalization workflow.
# When executed as the main program, it outputs the workflow to the designated file, with tasks lacking dependencies.
# Example usage:
#   ${O2DPG_ROOT}/DATA/production/o2dpg_qc_postproc_workflow.py -o qc_workflow.json


# The script can also be imported.
# In this scenario, one can utilize include_all_QC_finalization to incorporate QC finalization within another workflow script.

import sys
import importlib.util
import argparse
from os import environ, mkdir
from os.path import join, dirname, isdir

# Ensure O2DPG, O2, and QC are properly loaded
O2DPG_ROOT=environ.get('O2DPG_ROOT')
O2_ROOT=environ.get('O2_ROOT')
QUALITYCONTROL_ROOT=environ.get('QUALITYCONTROL_ROOT')

if O2DPG_ROOT is None: 
  print('Error: O2DPG needs to be loaded')
  sys.exit(1)

if O2_ROOT is None: 
  print('Error: O2 needs to be loaded')
  sys.exit(1)

if QUALITYCONTROL_ROOT is None:
  print('Error: QUALITYCONTROL_ROOT needs to be loaded')
  sys.exit(1)