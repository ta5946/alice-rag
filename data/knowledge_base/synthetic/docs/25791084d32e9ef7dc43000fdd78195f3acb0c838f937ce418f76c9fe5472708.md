## Metadata

**Document link:** https://github.com/AliceO2Group/O2DPG/blob/master/MC/bin/o2dpg_sim_config.py

**Start chunk id:** 25791084d32e9ef7dc43000fdd78195f3acb0c838f937ce418f76c9fe5472708

## Content

DOCUMENT:
    from functools import lru_cache
import subprocess
import re
import os

def create_sim_config(args):
    # generates a general simulation configuration
    # based on input arguments args (run number, energy, etc.) initially provided
    # to o2dpg_sim_workflow.py

    COLTYPEIR = args.col
    if args.embedding:
        COLTYPEIR = args.colBkg

    config = {}
    def add(cfg, flatconfig):
       for entry in flatconfig:
           mk = entry.split(".")[0]
           sk = entry.split(".")[1]
           d = cfg.get(mk,{})
           d[sk] = flatconfig[entry]
           cfg[mk] = d

---

# Using DEVNULL is crucial for o2-dpl workflows to avoid hanging in non-interactive environments without a terminal.
# This approach is more straightforward than using the echo | method.
output = subprocess.check_output([executable, "--help", "full"], env=env, text=True, stdin=subprocess.DEVNULL, timeout=100)
except subprocess.CalledProcessError:
    return {}, {}
    
option_pattern = re.compile(r"(\-\-[\w\-]+)")
sections = {}
inverse_lookup = {}
current_section = "global"
    
for line in output.split("\n"):
    section_match = re.match(r"^([A-Za-z\s]+):$", line.strip())
    if section_match:
        current_section = section_match.group(1).strip()
        sections[current_section] = []
        continue
        
    option_match = option_pattern.findall(line)
    if option_match:
        for option in option_match:
            sections.setdefault(current_section, []).append(option)

---

# FIT digitizer settings
# 2023 PbPb
if 543437 <= int(args.run) and int(args.run) <= 545367:
    add(config, {"FT0DigParam.mMip_in_V": "7", "FT0DigParam.mMV_2_Nchannels": "2", "FT0DigParam.mMV_2_NchannelsInverse": "0.5"})
    add(config, {"FV0DigParam.adcChannelsPerMip": "4"})
# 2024
# initial and final run of 2024
if 546088 <= int(args.run) and int(args.run) <= 560623:
    # 14 ADC channels per MIP for FT0
    add(config, {"FT0DigParam.mMip_in_V": "7", "FT0DigParam.mMV_2_Nchannels": "2", "FT0DigParam.mMV_2_NchannelsInverse": "0.5"})
    # 15 ADC channels per MIP for FV0
    add(config, {"FV0DigParam.adcChannelsPerMip": "15"})
    if COLTYPEIR == "PbPb":
        # 4 ADC channels per MIP for FV0
        add(config, {"FV0DigParam.adcChannelsPerMip": "4"})

return config

---

# specific settings for high pp
# data range sourced from https://twiki.cern.ch/twiki/bin/viewauth/ALICE/O2DPGMCSamplingSchema
# details from JIRA https://alice.its.cern.ch/jira/browse/O2-2691
# reduce additional errors in time margin for tracks and ITS clusters
add(config, {"pvertexer.timeMarginTrackTime" : 0.,
             "pvertexer.dbscanDeltaT" : 7,
             "pvertexer.maxChi2TZDebris": 50,
             "pvertexer.maxMultRatDebris": 1.,
             "pvertexer.dbscanAdaptCoef" : 20,
             "pvertexer.maxVerticesPerCluster" : 20,
             "pvertexer.dbscanMaxDist2" : 36})
else:
# general settings for pp
# reduce additional errors in time margin for tracks and ITS clusters
add(config, {"pvertexer.acceptableScale2" : 9,
             "pvertexer.dbscanMaxDist2" : 36,
             "pvertexer.dbscanDeltaT" : 24,})

---

# MFT tracking settings
if args.mft_reco_full:
    add(config, {"MFTTracking.forceZeroField" : 0,
                 "MFTTracking.LTFclsRCut" : 0.0100})

# Forward matching settings
if args.fwdmatching_4_param:
    add(config, {"FwdMatching.matchFcn" : "matchsXYPhiTanl"})
if args.fwdmatching_cut_4_param:
    add(config, {"FwdMatching.cutFcn" : "cut3SigmaXYAngles"})

# manage larger combinatorics
if args.col == "PbPb" or (args.embedding and args.colBkg == "PbPb"):
    add(config, {"ITSVertexerParam.lowMultBeamDistCut": "0."})

---

DOCUMENT:
    sections.setdefault(current_section, []).append(option)
    inverse_lookup.setdefault(option, []).append(current_section)
    
    return sections, inverse_lookup

---

# specific configurations for pp collisions
if COLTYPEIR == 'pp':
   # Alpide detector settings
   add(config, {"MFTAlpideParam.roFrameLengthInBC" : 198})
   if 302000 <= int(args.run) and int(args.run) < 309999:
       add(config, {"ITSAlpideParam.roFrameLengthInBC" : 198})
   # ITS reconstruction settings
   add(config, {"ITSVertexerParam.phiCut" : 0.5,
                "ITSVertexerParam.clusterContributorsCut" : 3,
                "ITSVertexerParam.tanLambdaCut" : 0.2})
   # primary vertex settings
   if 301000 <= int(args.run) and int(args.run) <= 301999:
       add(config, {"pvertexer.acceptableScale2" : 9,
                    "pvertexer.minScale2" : 2.,
                    "pvertexer.nSigmaTimeTrack" : 4.,
                    "pvertexer.timeMarginTrackTime" : 0.5,
                    "pvertexer.timeMarginVertexTime" : 7.,
                    "pvertexer.nSigmaTimeCut" : 10,})

---

@lru_cache(maxsize=10)
def get_dpl_options_for_executable(executable, envfile):
    """Provides available options and their inverse lookup for a specified executable, with the result cached."""
    return parse_dpl_help_output(executable, envfile)

def option_if_available(executable, option, envfile = None):
    """Determines if an option is available for a specific executable and returns it as a string. If not available, returns an empty string."""
    _, inverse_lookup = get_dpl_options_for_executable(executable, envfile)
    return ' ' + option if option in inverse_lookup else ''

---

"pvertexer.nSigmaTimeCut" : 10,
                       "pvertexer.dbscanMaxDist2" : 36,
                       "pvertexer.dcaTolerance" : 3.,
                       "pvertexer.pullIniCut" : 100,
                       "pvertexer.addZSigma2" : 0.1,
                       "pvertexer.tukey" : 20.,
                       "pvertexer.addZSigma2Debris" : 0.01,
                       "pvertexer.addTimeSigma2Debris" : 1.,
                       "pvertexer.maxChi2Mean" : 30,
                       "pvertexer.timeMarginReattach" : 3.,
                       "pvertexer.dbscanDeltaT" : 24,
                       "pvertexer.maxChi2TZDebris" : 100,
                       "pvertexer.maxMultRatDebris" : 1.,
                       "pvertexer.dbscanAdaptCoef" : 20.}
       elif 302000 <= int(args.run) and int(args.run) <= 309999:
          # specific settings for high pp runs

---

"pvertexer.dbscanDeltaT" : 24,
                       "pvertexer.maxChi2TZDebris" : 100,
                       "pvertexer.maxMultRatDebris" : 1.,
                       "pvertexer.dbscanAdaptCoef" : 20.)

---

DOCUMENT:
    return config


def create_geant_config(args, externalConfigString):
    # generates a generic transport simulation configuration based on the arguments (run number, energy, etc.) originally provided to o2dpg_sim_workflow.py
    #
    # returns a dictionary with mainkey -> dictionary of subkey : values
    config = {}
    def add(cfg, flatconfig):
       for entry in flatconfig:
           mk = entry.split(".")[0]
           sk = entry.split(".")[1]
           d = cfg.get(mk,{})
           d[sk] = flatconfig[entry]
           cfg[mk] = d

    # ----- special setting for the hepmc generator -----
    if args.gen == "hepmc":
      eventSkipPresent = config.get("HepMC",{}).get("eventsToSkip")
      if eventSkipPresent == None:
          # add it
          add(config, {"HepMC.eventsToSkip" : '${HEPMCEVENTSKIP:-0}'})

    # ----- add default settings -----

    add(config, {"MFTBase.buildAlignment" : "true"})

---

DOCUMENT:
    # Ignore empty lines or comments
    if not line or line.startswith("#"):
        continue

    # Remove 'declare -x ' if present
    if line.startswith("declare -x "):
        line = line.replace("declare -x ", "", 1)

    # Handle case: "FOO" without "=" (assign empty string)
    if "=" not in line:
        key, value = line.strip(), ""
    else:
        key, value = line.split("=", 1)
        value = value.strip('"')  # Remove surrounding quotes if present

    env_vars[key.strip()] = value
    return env_vars

# functions to determine dpl option availability dynamically
def parse_dpl_help_output(executable, envfile):
    """Parses the --help full output of an executable to extract available options."""
    try:
        env = os.environ.copy()
        if envfile is not None:
            print("Loading from alternative environment")
            env = load_env_file(envfile)

---

# helper function to update certain values and logs the changes made
def update_config(config, mainkey, subkey, value):
    oldvalue = config.get(mainkey,{}).get(subkey, None)
    print (f"Updating {mainkey}.{subkey}: {'None' if oldvalue is None else oldvalue} -> {value}")
    if mainkey not in config:
      # Initialize the main key in the dictionary if it does not already exist
      config[mainkey] = {}
    config[mainkey][subkey] = value

---

# ----- add default settings -----

add(config, {"MFTBase.buildAlignment" : "true"})

# ----- apply external overwrites from command line ------
for keyval in externalConfigString.split(";"):
    if len(keyval) > 0:
        key, val = keyval.split("=")
        add(config, {key : val})

return config

def constructConfigKeyArg(config):
    # flattens the dictionary created in create_geant_config
    # and forms the --configKeyValues options for the simulation
    if len(config) == 0:
        return ''
    arg = '--configKeyValues "'
    for mainkey in config:
        for subkey in config[mainkey]:
            arg = arg + mainkey + '.' + subkey + '=' + config[mainkey][subkey] + ';'
    arg = arg + '"'
    return arg

def load_env_file(env_file):
    """Converts an environment file produced by 'export > env.txt' into a python dictionary."""
    env_vars = {}
    with open(env_file, "r") as f:
        for line in f:
            line = line.strip()