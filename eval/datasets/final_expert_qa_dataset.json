[
  {
    "id": 1,
    "author": "Marco",
    "question": "How do you run a simple simulation at generation level?",
    "correct_answer": "The basic way is to use the o2-sim executable provided natively by the O2sim environment.\nThe executable allows to enable particle transport through a simulated version of the ALICE subdetectors via Geant4 (default), Geant3 or FLUKA. \nThe easiest command one could execute is:\n```\no2-sim -n 10 -g pythia8pp\n```\nwhich will run 10 events with the default configuration of Pythia8 in pp collisions transported using Geant4."
  },
  {
    "id": 2,
    "author": "Marco",
    "question": "What are the differences between using o2-sim and running a full simulation workflow?",
    "correct_answer": "o2-sim is the main executable to run simulations, but it's a single step that will ultimately lead to a kinematic file and Hits files if the particles are transported to the various subdetectors. A simulation workflow instead contains multiple steps that mimic entirely the data workflow of the ALICE experiment."
  },
  {
    "id": 3,
    "author": "Marco",
    "question": "Which generators are natively included in AliGenO2?",
    "correct_answer": "From the alidist recipe of the package, one can make a list of all the generators contained, which are:\n- DPMJET\n- POWHEG\n- PYTHIA8\n- ThePEG\n- SHERPA\n- JETSCAPE\n- CRMC\n- EPOS4\n- EPOS4HQ\n- STARlight\n- Upcgen\n- Graniitti\n- nOOn"
  },
  {
    "id": 4,
    "author": "Marco",
    "question": "How do you create and use event pools?",
    "correct_answer": "The creation of event pools is done via the `--make-evtpool` flag of the workflow creator. This generates a JSON workflow that skips the AOD creation and, instead, moves to a *poolmerge* step that merges the output from the various timeframes generated into a single `evtpool.root` file.\nAn easy example is:\n```bash\n${O2DPG_ROOT}/MC/bin/o2dpg_sim_workflow.py -gen pythia8pp -eCM 13000 -tf 8 -ns 100 --make-evtpool -interactionRate 500000 -seed 123\n${O2DPG_ROOT}/MC/bin/o2dpg_workflow_runner.py -f workflow.json -tt pool\n```\nThe generated file can later be used via the `evtpool` generator that allows multiple events reading customisations (round-robin, randomisation etc.) and is compatible with either local paths or alien ones, making it extremely versatile. A configuration example using the hybrid generator is:\n```JSON\n{\n  \"name\": \"evtpool\",\n  \"config\": {\n    \"eventPoolPath\": \"alien:///alice/sim/2025/EP25f1/2\",\n    \"skipNonTrackable\": true,\n    \"roundRobin\": false,\n    \"randomize\": true,\n    \"rngseed\": 0,\n    \"randomphi\": false\n  }\n}\n```"
  },
  {
    "id": 5,
    "author": "Marco",
    "question": "Can you provide CCDB objects for simulations instead of downloading them each time? If so, how?",
    "correct_answer": "Yes this is achievable thanks to local CCDB snapshots. The O2DPG workflow fetches automatically all the CCDB objects and caches them into the current execution path in a *ccdb* folder. Instead of downloading them each time, experts can provide local folders using:\n```bash\nexport ALICEO2_CCDB_LOCALCACHE=/<your>/<path>\n```\nor while executing the workflow runner with:\n```bash\nALICEO2_CCDB_LOCALCACHE=${YOURPATH} o2_dpg_workflow_runner.py …\n```\nMoreover a script is available to download CCDB objects manually\n```bash\n${O2_ROOT}/bin/o2-ccdb-downloadccdbfile --host http://alice-ccdb.cern.ch -p TPC/Calib/CorrectionMapRef --timestamp <timestamp> --created-not-after 3385078236000 \n-d ${YOURPATH}\n```"
  },
  {
    "id": 6,
    "author": "Marco",
    "question": "What are the components of a full simulation workflow?",
    "correct_answer": "A simplified list of all the steps is:\n- Simulation configuration &rarr; CCDB objects are downloaded and the global run parameters are set\n- Collisions simulation &rarr; particles collisions are generated via the pre-defined Monte Carlo generator\n- Particles transport &rarr; output from previous step is transported via GEANT4 (by default) to the virtual representation of the ALICE detectors taken into account\n- Digitisation &rarr; virtual hits from the transport are digitised, as if they were transformed from real detectors analogic signals\n- Reconstruction &rarr; tracks of the subdetectors are found\n- Tracks matching &rarr; the output from the various detectors are processed to match together their signals\n- Vertexing &rarr; primary and secondary vertexes are built\n- AO2D creation \n"
  },
  {
    "id": 7,
    "author": "Marco",
    "question": "Can you read HepMC formatted data?",
    "correct_answer": "Yes, **O2sim** includes the custom *GeneratorHepMC* that is able to read both HepMC2 and HepMC3 output."
  },
  {
    "id": 8,
    "author": "Marco",
    "question": "Is there a way to generate data on-the-fly for hyperloop usage?",
    "correct_answer": "o2-sim can be used as on-the-fly generator for analysis purposes injecting events directly into a DPL topology without intermediate storage. This can be used in hyperloop trains and it is useful for fast-simulation studies within analysis framework. An example: \n```bash\n# Launch simulation\no2-sim -j 1 -g pythia8pp -n 10 --noDiscOutput --forwardKine --noGeant &> sim.log &\n# Launch a DPL process\no2-sim-mctracks-proxy -b --nevents 10 --o2sim-pid ${SIMPROC} --aggregate-timeframe 1 &\n```\nOn Hyperloop this is done by generating a dummy dataset containing the ini file that will be picked up for the simulation."
  },
  {
    "id": 9,
    "author": "Marco",
    "question": "Is there a simple mechanism to combine particles coming from different generators for each event?",
    "correct_answer": "The hybrid generator allows to combine multiple generators output through the cocktail system: each event will contain sequentially the results of each generator.\nIt is straightforward to configure and an example is: \n```JSON\n{\n  \"mode\": \"sequential\",\n  \"generators\": [\n    {\n      \"cocktail\": [\n        {\n          \"name\": \"evtpool\",\n          \"config\": {\n            \"eventPoolPath\": \"alien:///alice/sim/2025/EP25f1/2\",\n            \"skipNonTrackable\": true,\n            \"roundRobin\": false,\n            \"randomize\": true,\n            \"rngseed\": 0,\n            \"randomphi\": false\n          }\n        },\n        {\n          \"name\": \"external\",\n          \"config\": {\n            \"fileName\": \"${O2DPG_MC_CONFIG_ROOT}/MC/config/common/external/generator/TPCLoopers.C\",\n            \"funcName\": \"Generator_TPCLoopers(\\\"ccdb://Users/m/mgiacalo/WGAN_ExtGenPair\\\", \\\"ccdb://Users/m/mgiacalo/WGAN_ExtGenCompton\\\", \\\"${O2DPG_MC_CONFIG_ROOT}/MC/config/common/TPCloopers/poisson_params.csv\\\", \\\"${O2DPG_MC_CONFIG_ROOT}/MC/config/common/TPCloopers/gaussian_params.csv\\\", \\\"${O2DPG_MC_CONFIG_ROOT}/MC/config/common/TPCloopers/ScalerPairParams.json\\\", \\\"${O2DPG_MC_CONFIG_ROOT}/MC/config/common/TPCloopers/ScalerComptonParams.json\\\", {4.,4.})\",\n            \"iniFile\": \"\"\n          }\n        }\n      ]\n    }\n  ],\n  \"fractions\": [\n    1\n  ]\n}\n\n```"
  },
  {
    "id": 10,
    "author": "Marco",
    "question": "Which tool can be used to run a test production on the GRID using the users quota? How does it work?",
    "correct_answer": "The O2DPG package comes with the `grid_submit.sh` tool that can be used to submit GRID jobs using your personal quota. It is a powerful script allowing the user to push simulation shell scripts on AliEN and automatically run them without generating beforehand a JDL. It is highly configurable with both flags and bash comments setting up for example output files, loaded packages and specific run requirements. The user can learn about the most used options by using the common `--help` flag, while the rest is described directly in the source code of the script, located in the `${O2DPG_ROOT}/GRID/utils` folder. A short example is provided below.\n<h5 a><strong><code>my_script.sh</code></strong></h5>\n\n```bash\n#!/usr/bin/env bash\n# Workflow creation: step 1\n${O2DPG_ROOT}/MC/bin/o2dpg_sim_workflow.py -eCM 13600 -col pp -gen pythia8 -proc cdiff -tf 1 -ns 200 -e TGeant4 -interactionRate 500000\n# Workflow execution: step 2\n${O2DPG_ROOT}/MC/bin/o2dpg_workflow_runner.py -f workflow.json -tt aod\n```\n<h5 a><strong><code>Execution command</code></strong></h5>\n\n```bash\n${O2DPG_ROOT}/GRID/utils/grid_submit.sh --script my_script.sh --jobname test --outputspec \"*.log@disk=1\",\"*.root@disk=2\" --packagespec \"VO_ALICE@O2sim::v20250808-1\"\n```"
  },
  {
    "id": 11,
    "author": "Sandro",
    "question": "How can I run a basic ALICE detector simulation for Run3?",
    "answer": "Use the Run3 detector simulator `o2-sim`. A typical basic example provided is:\n\n`o2-sim -g pythia8pp -e TGeant4 -n 10 -j 8`\n\nThis runs a Pythia8 pp generator, uses Geant4 (`-e TGeant4`), simulates 10 events (`-n 10`) in the full ALICE geometry and runs on 8 workers (`-j 8`). For Run3 the simulator is rewritten to be fully multi-core capable and asynchronous. The integrated MC workflow (O2DPG) is the official way to run ALICE MC; full `o2-sim` docs and examples are in the provided links."
  },
  {
    "id": 12,
    "author": "Sandro",
    "question": "How to run Run3 detector simulation?",
    "answer": "Run the `o2-sim` executable (the Run3 detector simulation was rewritten to be multi-core and asynchronous). A concrete example is:\n\n`o2-sim -g pythia8pp -e TGeant4 -n 10 -j 8`\n\nThis steers event generation, detector geometry/material construction and particle transport; use the O2DPG setup (official MC workflow) and refer to the `o2-sim` documentation and SimExamples in the AliceO2 repository for more examples."
  },
  {
    "id": 13,
    "author": "Sandro",
    "question": "How to run Run3 Geant simulation?",
    "answer": "Use `o2-sim` and select a Geant backend via the VMC engine option. Example for Geant4:\n\n`o2-sim -g pythia8pp -e TGeant4 -n 10 -j 8`\n\n`o2-sim` uses a VMC abstraction that lets you choose Geant4, Geant3 or FLUKA as the actual simulator backend; the example above runs Geant4 on 8 workers for 10 events."
  },
  {
    "id": 14,
    "author": "Sandro",
    "question": "Describe the o2-sim executable.",
    "answer": "`o2-sim` is the ALICE detector simulation executable that transforms virtual particle collisions into detector-response information (hits). It steers event generation, constructs the detector geometry and material and performs particle-transport simulation via a Virtual Monte Carlo (VMC) abstraction so users can choose Geant4, Geant3 or FLUKA as backend. `o2-sim` produces hit files for each sensitive detector (e.g. `o2sim_HitsITS.root`) and a kinematics file (by default `o2sim_Kine.root`) containing primary and secondary particle information. For Run3 it is fully multi-core capable and asynchronous. Full documentation and examples are available in the provided links, and the O2DPG repository provides the integrated/official MC workflow."
  },
  {
    "id": 15,
    "author": "Sandro",
    "question": "How can I run the production MC workflow for ALICE?",
    "answer": "Use the O2DPG-provided workflows which integrate the AliceO2 executables into end-to-end MC pipelines. Two supported ways are:\n\n1) Build and run a workflow explicitly with the two O2DPG Python scripts:\n\n- Create the workflow description (workflow.json) with `o2dpg_sim_workflow.py` and then execute it with `o2dpg_workflow_runner.py`.\n\nExample:\n`\n${O2DPG_ROOT}/MC/bin/o2dpg_sim_workflow.py -eCM 14000  -col pp -gen pythia8 -tf 1 -ns 2000 --interactionRate 500000 -run 302000\n\n${O2DPG_ROOT}/MC/bin/o2dpg_workflow_runner.py -f workflow.json -tt aod\n`\nThis configures a complete simulation for 1 timeframe of pp collisions and runs up to the `aod` stage.\n\n2) (Typical user) Use the provided anchor script `anchorMC.sh`, which manages setup and execution for MC that matches real data-taking conditions. You set a few obligatory environment variables (data-taking period, reconstruction pass, plus generator options) and call the script. Detailed docs are available in the O2DPG documentation (anchored workflow)."
  },
  {
    "id": 16,
    "author": "Sandro",
    "question": "Script to run MC in ALICE3?",
    "answer": "The primary user-facing script is `anchorMC.sh` (located in `${O2DPG_ROOT}/MC/run/ANCHOR/anchorMC.sh`). Set the required environment variables (data-taking period, pass, run number, production tag, and generator options) and invoke the script. Example header shown in the provided text:\n\n`\n# Define obligatory environment variables\nexport ALIEN_JDL_LPMANCHORPASSNAME=apass4\nexport ALIEN_JDL_MCANCHOR=apass4\nexport ALIEN_JDL_CPULIMIT=8\nexport ALIEN_JDL_LPMRUNNUMBER=545312\nexport ALIEN_JDL_LPMPRODUCTIONTYPE=MC\nexport ALIEN_JDL_LPMINTERACTIONTYPE=Pb-Pb\nexport ALIEN_JDL_LPMPRODUCTIONTAG=LHC24a2_mystudy\nexport ALIEN_JDL_LPMANCHORRUN=545312\nexport ALIEN_JDL_LPMANCHORPRODUCTION=LHC23zzo\nexport ALIEN_JDL_LPMANCHORYEAR=2023\n\n# event generator config\nexport ALIEN_JDL_ANCHOR_SIM_OPTIONS=\"-gen pythia8pp\"\n\n# numbers\nexport NTIMEFRAMES=2\nexport NSIGEVENTS=5000\nexport PRODSPLIT=100\nexport SPLITID=50\nexport CYCLE=0\n\n# start the workflow\n${O2DPG_ROOT}/MC/run/ANCHOR/anchorMC.sh\n`\n\nFor advanced or expert-mode setups you can instead build a workflow with `o2dpg_sim_workflow.py` and run it with `o2dpg_workflow_runner.py` as shown above."
  },
  {
    "id": 17,
    "author": "Sandro",
    "question": "How can I load the software necessary to run simulation, reconstruction etc?",
    "answer": "You can load the `O2PDPSuite` package from CVMFS using the `alienv` command:\n```\n/cvmfs/alice.cern.ch/bin/alienv enter O2PDPSuite::VERSION\n```\nwhere `VERSION` is a specific tag such as `O2PDPSuite::MC-prod-2025-v1-2` or a daily release like `daily-20250711-0000-1`. Alternatively, you can build the software stack yourself using the aliBuild/alidist ecosystem (instructions: https://alice-doc.github.io/alice-analysis-tutorial/building/)."
  },
  {
    "id": 18,
    "author": "Sandro",
    "question": "What software packages are required to run the simulation pipeline?",
    "answer": "The `O2PDPSuite` software package provides all necessary components to run the Monte Carlo pipeline for ALICE in Run3 and also to do physics analysis."
  },
  {
    "id": 19,
    "author": "Sandro",
    "question": "Software packages for ALICE simulation?",
    "answer": "`O2PDPSuite`, deployed on CVMFS, contains all required software for ALICE simulation and analysis."
  },
  {
    "id": 20,
    "author": "Sandro",
    "question": "How can I configure ALICE MC?",
    "answer": "Configuration of Monte Carlo simulation happens with a mix of command line options and configurable parameters (ConfigurableParams). The `o2-sim` executable has command line options to set top-level choices such as the event generator, the simulator backend, the output filename, etc. (see `o2-sim --help`). ConfigurableParams are two-level key-value strings `MainKey.SubKey=Value` passed via the `--configKeyValues` option; the main key addresses a broader category and the sub-key a specific modifiable variable. Example configurable parameter: `G4Params.configMacroFile` to set a Geant4 input file. Full example: `o2-sim -e TGeant4 --configKeyValues=\"G4Params.configMacroFile=myG4config.in\"`. Under the hood ConfigurableParams are C++ classes registered in a service whose registry knows all available configurable params and can spot wrong keys/sub-keys."
  },
  {
    "id": 21,
    "author": "Sandro",
    "question": "How can I configure ALICE Run3 simulation?",
    "answer": "Use the `o2-sim` top-level command line options for high-level choices and ConfigurableParams (`MainKey.SubKey=Value`) for deeper runtime configuration, passed with `--configKeyValues`. Example: `o2-sim -e TGeant4 --configKeyValues=\"G4Params.configMacroFile=myG4config.in\"`."
  },
  {
    "id": 22,
    "author": "Sandro",
    "question": "What event-generators are supported?",
    "answer":  null
  },
  {
    "id": 23,
    "author": "Sandro",
    "question": "How can I set a particular event generator for simulation?",
    "answer": "Pass the generator with the `-g` option to `o2-sim`. Example from the text: `o2-sim -g pythia8hi -n 11 --noGeant`."
  },
  {
    "id": 24,
    "author": "Sandro",
    "question": "How can I only obtain the output of the event-generation stage?",
    "answer": "Three options are described:\n1) Use `o2-sim` with the `--noGeant` option to skip detector simulation; example: `o2-sim -g pythia8hi -n 11 --noGeant` — collision output will be in `o2sim_Kine.root`.\n2) Use the dedicated `o2-sim-dpl-eventgen` tool which focuses only on event generation and injects events on-the-fly into O2Physics (it typically does not store the collision output to a file). Examples live in `run/SimExamples/McTracksToAOD` in the AliceO2 repository.\n3) With the integrated O2DPG workflow, generate `workflow.json` using `o2dpg_sim_workflow.py` and run the workflow up to the `sgngen` stage: `${O2DPG_ROOT}/bin/o2dpg_workflow_runner.py -f workflow.json -tt sgngen`."
  },
  {
    "id": 25,
    "author": "Sandro",
    "question": "How to do only event generation?",
    "answer": "Use one of the three options to perform only event generation:\n• `o2-sim --noGeant` to produce `o2sim_Kine.root` without Geant;\n• `o2-sim-dpl-eventgen` to inject generated events on-the-fly (usually without writing a file);\n• stop the O2DPG workflow after the event-generation stage by running the generated `workflow.json` up to `sgngen` with `${O2DPG_ROOT}/bin/o2dpg_workflow_runner.py -f workflow.json -tt sgngen`."

  },
  {
    "id": 26,
    "author": "Sandro",
    "question": "How can I simulate only specific detectors in the ALICE MC pipeline?",
    "answer": "On the level of the `o2-sim` detector simulation executable you can: (1) use `-m` to specify the exact list of modules to include, e.g. `o2-sim -m PIPE ITS TPC`; (2) use `--skipModules` to exclude modules from the full detector, e.g. `o2-sim --skipModules ZDC`; (3) instantiate the complete detector material but request hits only from certain sensitive detectors with `--readoutDetectors`, e.g. `o2-sim --skipModules ZDC --readoutDetectors ITS TPC`. On the level of the complete O2DPG MC workflows use the similar `--readoutDets` option with `o2dpg_sim_workflow.py`."
  },
  {
    "id": 27,
    "author": "Sandro",
    "question": "Where can I find the documentation for ALICE detector simulation?",
    "answer": "The main documentation is available at [https://aliceo2group.github.io/simulation/](https://aliceo2group.github.io/simulation/)."
  },
  {
    "id": 28,
    "author": "Sandro",
    "question": "Where can I find the documentation for ALICE Run3 MC?",
    "answer": "The main documentation is available at [https://aliceo2group.github.io/simulation/](https://aliceo2group.github.io/simulation/). In addition, concrete examples for the o2-sim detector simulator or event-generator setup are available at [https://github.com/AliceO2Group/AliceO2/tree/dev/run/SimExamples](https://github.com/AliceO2Group/AliceO2/tree/dev/run/SimExamples)."
  },
  {
    "id": 29,
    "author": "Sandro",
    "question": "How to obtain support for ALICE simulation?",
    "answer": "User-support can be obtained via dedicated Mattermost channels: [https://mattermost.web.cern.ch/alice/channels/o2-simulation](https://mattermost.web.cern.ch/alice/channels/o2-simulation)."
  },
  {
    "id": 30,
    "author": "Sandro",
    "question": "Where or how should I report bugs or ask for feature requests for simulation?",
    "answer": "Bug reports and feature requests should be made at [https://its.cern.ch/jira/projects/O2](https://its.cern.ch/jira/projects/O2) with tickets mentioning \"simulation\"."
  },
  {
    "id": 31,
    "author": "Sandro",
    "question": "What is a MClabel in ALICE run3 simulation",
    "answer": "In ALICE Run3 a Monte Carlo label (MCLabel) is the triple (source_id, event_id, track_id). It identifies a particular Monte Carlo particle across possibly multiple kinematics files and is provided via the C++ class o2::MCCompLabel."
  },
  {
    "id": 32,
    "author": "Sandro",
    "question": "What about MC labels in ALICE simulation?",
    "answer": "MCLabels allow combining multiple kinematics sources (e.g. for signal-background combinations) by adding a source_id to the (event_id, track_id) pair. Products of the computing chain (digits, clusters, reconstructed tracks) typically refer to one or more MCLabels to keep provenance information of the contributing particles."
  },
  {
    "id": 33,
    "author": "Sandro",
    "question": "How does MCTruth work?",
    "answer": "MCTruth analysis is based on MCLabels and the stored Monte Carlo information: generator and detector-simulation particles are saved as MCTrack objects in kinematics files (e.g. o2sim_Kine.root). An MCTrack encodes particle properties at creation; TrackReferences are snapshots of track properties along the trajectory (one MCTrack can have multiple TrackReferences). Kinematics files contain a vector of MCTracks per event, addressable by (event_id, track_id), and with multiple kinematic files by source_id — together forming the MCLabel used to trace provenance for closure tests, physics analysis and efficiency studies."
  },
  {
    "id": 34,
    "author": "Sandro",
    "question": "How to access MC tracks given a MC label?",
    "answer": "Initialize an MCKinematicsReader with either a kinematics file or a digitization (or collision) context. Then use the interface: MCTrack const& MCKinematicsReader::getTrack(MCCompLabel const&) const to translate a MCLabel (MCCompLabel) into an MCTrack. If you need all tracks for a particular event (single source_id) you can also use: std::vector<MCTrack> const& getTracks(int event) const."
  },
  {
    "id": 35,
    "author": "Sandro",
    "question": "How to access TrackReferences?",
    "answer": "Use gsl::span[o2::TrackReference](o2::TrackReference) getTrackRefs(int source, int event, int track) const to fetch TrackReferences belonging to a given MCLabel."
  },
  {
    "id": 36,
    "author": "Sandro",
    "question": "Provide an example of job script running anchored MC",
    "answer": "#!/usr/bin/env bash\n\n# Define some obligatory environment variables\n# referencing/defining the data taking period for this MC\nexport ALIEN_JDL_LPMANCHORPASSNAME=apass4\nexport ALIEN_JDL_MCANCHOR=apass4\nexport ALIEN_JDL_CPULIMIT=8\nexport ALIEN_JDL_LPMRUNNUMBER=545312\nexport ALIEN_JDL_LPMPRODUCTIONTYPE=MC\nexport ALIEN_JDL_LPMINTERACTIONTYPE=Pb-Pb\nexport ALIEN_JDL_LPMPRODUCTIONTAG=LHC24a2_mystudy\nexport ALIEN_JDL_LPMANCHORRUN=545312\nexport ALIEN_JDL_LPMANCHORPRODUCTION=LHC23zzo\nexport ALIEN_JDL_LPMANCHORYEAR=2023\n\n# event generator config to be used \nexport ALIEN_JDL_ANCHOR_SIM_OPTIONS=\"-gen pythia8pp\" \n\n# some numbers\nexport NTIMEFRAMES=2   # number of timeframes to do \nexport NSIGEVENTS=5000 # <-- an upper boundary; actual number is the min of this and what fits into a timeframe\nexport PRODSPLIT=100\nexport SPLITID=50\nexport CYCLE=0\n\nexport ALIEN_PROC_ID=${ALIEN_PROC_ID:-2963436952}\n\n# start the actual workflow\n${O2DPG_ROOT}/MC/run/ANCHOR/anchorMC.sh\n\nThis script will run a single MC job for run number 545312 of the 2023 PbPb data taking period for 2 timeframes. Note that in an actual MC production on the GRID, the only line that a user should provide is `ALIEN_JDL_ANCHOR_SIM_OPTIONS` to define the event generator setup and the rest is filled or provided by the operator or the system."
  }
]
